CREATE DATABASE /*!32312 IF NOT EXISTS*/`tensquare_blog` /*!40100 DEFAULT CHARACTER SET utf8 */;

USE `tensquare_blog`;

/*
 Navicat Premium Data Transfer

 Source Server         : mysql
 Source Server Type    : MySQL
 Source Server Version : 80016
 Source Host           : 132.232.104.247:3306
 Source Schema         : tensquare_blog

 Target Server Type    : MySQL
 Target Server Version : 80016
 File Encoding         : 65001

 Date: 23/07/2019 19:22:27
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for tb_article
-- ----------------------------
DROP TABLE IF EXISTS `tb_article`;

CREATE TABLE `tb_article` (
  `id` varchar(20) NOT NULL COMMENT 'ID',
  `userid` varchar(20) DEFAULT NULL COMMENT '用户ID',
  `title` varchar(100) DEFAULT NULL COMMENT '标题',
  `summary` text COMMENT '摘要',
  `content` longtext COMMENT '文章正文',
  `textcontent` longtext COMMENT '文章纯文本',
  `image` varchar(200) DEFAULT NULL COMMENT '文章封面',
  `createtime` datetime DEFAULT NULL COMMENT '发表日期',
  `updatetime` datetime DEFAULT NULL COMMENT '修改日期',
  `ispublic` varchar(1) DEFAULT NULL COMMENT '是否公开',
  `istop` varchar(1) DEFAULT NULL COMMENT '是否置顶',
  `visits` int(20) DEFAULT NULL COMMENT '浏览量',
  `thumbup` int(20) DEFAULT NULL COMMENT '点赞数',
  `comment` int(20) DEFAULT NULL COMMENT '评论数',
  `state` varchar(1) DEFAULT NULL COMMENT '审核状态',
  `categoryid` varchar(20) DEFAULT NULL COMMENT '所属类型',
  `category_name` varchar(20) DEFAULT NULL COMMENT '类型名称',
  `url` varchar(100) DEFAULT NULL COMMENT 'URL',
  `type` varchar(1) DEFAULT NULL COMMENT '类型（原创、转载、翻译）',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='文章';

-- ----------------------------
-- Records of tb_article
-- ----------------------------
BEGIN;
INSERT INTO `tb_article` VALUES ('1142303057879633920', NULL, 'IDEA生成java说明文档', '本章内容通过Nginx 和 FTP 搭建图片服务器。在学习本章内容前，请确保您的Linux 系统已经安装了Nginx和Vsftpd。Nginx 安装http://www.cnblogs.com/itdragon/p/7850985.htmlVsftpd 安装http://www.cnblogs.com/itdragon/p/7857649.html', '<h3>docker_fastdfs 分布式文件服务器单机版搭建</h3>\n\n<hr/>\n\n<ol><li>拉取镜像并启动\n<code>bash\ndocker run -d --privileged=true \\\n--net=host --name=fastdfs \\\n-e IP=132.232.104.247 -e WEB_PORT=9999 \\\n-v /server/fastdfs:/var/local/fdfs \\\nregistry.cn-beijing.aliyuncs.com/tianzuo/fastdfs\n</code></li></ol>\n\n<p>如果需要每次重新启动,  使用这个命令，加上 --restart=always\n<code>bash\n    docker run -d --privileged=true \\\n    --restart=always \\\n    --net=host --name=fastdfs \\\n    -e IP=132.232.104.247 -e WEB_PORT=9999 \\\n    -v /server/fastdfs:/var/local/fdfs \\\n    registry.cn-beijing.aliyuncs.com/tianzuo/fastdfs\n</code>\n<em> -e IP=132.232.104.247 是服务器的公网ip\n</em> -e WEB_PORT=9999 指定镜像中集成的nginx的端口，后面是用来访问图片或者文件\n* -v /server/fastdfs:/var/local/fdfs 挂载容器中存储文件的目录</p>\n\n<ol><li><p>容器启动之后：进行测试： \n<code>bash\n进入容器\ndocker exec -it fastdfs /bin/bash\n</code>\n<code>bash\n创建文件\necho &quot;Hello FastDFS!&quot;&gt;index.html\n</code>\n<code>bash\n上传文件,会返回上传文件的路径 一般是: /group1/M00/00 这种的\nfdfs_test /etc/fdfs/client.conf upload index.html\n</code></p></li><li><p>在浏览器访问 ip:port/path <br/>ip: 就是服务器公网ip <br/>port: 是run docker时指定的-e WEB_PORT指定的port\npath: 是上传文件之后返回的路径</p></li></ol>\n\n<hr/>\n\n<p>TODO 后面整理 springboot集成 fastdfs\n1. 两种pom依赖：\n<code>java\n&lt;dependency&gt;\n    &lt;groupId&gt;com.luhuiguo&lt;/groupId&gt;\n    &lt;artifactId&gt;fastdfs-spring-boot-starter&lt;/artifactId&gt;\n    &lt;version&gt;0.2.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></p>\n\n<p><code>java\n&lt;dependency&gt;\n    &lt;groupId&gt;com.github.tobato&lt;/groupId&gt;\n    &lt;artifactId&gt;fastdfs-client&lt;/artifactId&gt;\n    &lt;version&gt;1.26.2&lt;/version&gt;\n&lt;/dependency&gt;\n</code></p>\n\n<p>使用方式好像一样的   </p>\n\n<ul><li>[ ] springboot中集成fastdfs</li></ul>', NULL, '2019-06-22 13:27:27', NULL, NULL, NULL, '0', 0, 0, 0, '1', '1', NULL, '1', NULL);
INSERT INTO `tb_article` VALUES ('1142308173135351808', NULL, '这是一个标题', '本章内容通过Nginx 和 FTP 搭建图片服务器。在学习本章内容前，请确保您的Linux 系统已经安装了Nginx和Vsftpd。Nginx 安装http://www.cnblogs.com/itdragon/p/7850985.htmlVsftpd 安装http://www.cnblogs.com/itdragon/p/7857649.html', '1、打开 idea，点击 Tools-> Generate JavaDoc，这样会打开生成 javadoc 文档的配置页面。2、进行配置：标注的是重要的部分，从上往下分别是配置 javadoc 的范围，输出文件夹路径以及命令行参数。这里的命令行参数很重要，因为只有使用 utf-8 编码才能保证生成时可以正常处理中文字符，所以一定要加上：-encoding utf-8 -charset utf-81还可以配置那些注解需要生成，哪些权限类（private、package、protected、public）需要生成等等精细的控制。还有一点需要注意，即不要勾选“Include test sources”，勾选后，生成时会造成很奇怪的错误。3、配置好后，点击生成按钮，生成好后就会自动在浏览器打开进行查看咯，是不是很棒O(∩_∩)O~--------------------- 作者：deniro_li 来源：CSDN 原文：https://blog.csdn.net/deniro_li/article/details/71706267 版权声明：本文为博主原创文章，转载请附上博文链接！', NULL, '2019-06-22 13:47:46', NULL, NULL, NULL, '0', 99, 12, 0, '6', '1142309021223620608', NULL, '1', NULL);
INSERT INTO `tb_article` VALUES ('1142308371337187328', NULL, 'spring boot的jar包的启动，停止脚本', '一、背景 spring boot的项目越来越多的打包成jar包来启动了。 二、脚本封装 脚本名为jarboot.sh，该脚本能启', '在开发过程中，经常需要和别的系统交换数据，数据交换的格式有XML、JSON等，JSON作为一个轻量级的数据格式比xml效率要高，XML需要很多的标签，这无疑占据了网络流量，JSON在这方面则做的很好，下面先看下JSON的格式，\n\nJSON可以有两种格式，一种是对象格式的，另一种是数组对象，\n\n{\"name\":\"JSON\",\"address\":\"北京市西城区\",\"age\":25}//JSON的对象格式的字符串\n \n\n[{\"name\":\"JSON\",\"address\":\"北京市西城区\",\"age\":25}]//数据对象格式\n\n从上面的两种格式可以看出对象格式和数组对象格式唯一的不同则是在对象格式的基础上加上了[]，再来看具体的结构，可以看出都是以键值对的形式出现的，中间以英文状态下的逗号（,）分隔。\n\n在前端和后端进行数据传输的时候这种格式也是很受欢迎的，后端返回json格式的字符串，前台使用js中的JSON.parse()方法把JSON字符串解析为json对象，然后进行遍历，供前端使用。\n\n下面进入正题，介绍在JAVA中JSON和java对象之间的互转。\n\n要想实现JSON和java对象之间的互转，需要借助第三方jar包，这里使用json-lib这个jar包，下载地址为：https://sourceforge.net/projects/json-lib/，json-lib需要commons-beanutils-1.8.0.jar、commons-collections-3.2.1.jar、commons-lang-2.5.jar、commons-logging-1.1.1.jar、ezmorph-1.0.6.jar五个包的支持，可以自行从网上下载，这里不再贴出下载地址。\n\njson-lib提供了几个类可以完成此功能，例，JSONObject、JSONArray。从类的名字上可以看出JSONObject转化的应该是对象格式的，而JSONArray转化的则应该是数组对象（即，带[]形式）的。\n\n一、java普通对象和json字符串的互转\n\n  java对象--》》字符串\n\njava普通对象指的是java中的一个java bean，即一个实体类，如，', NULL, '2019-06-22 13:48:33', NULL, NULL, NULL, '0', 99, 12, 0, '3', '6', NULL, '1', NULL);
INSERT INTO `tb_article` VALUES ('1142308467445469184', NULL, '整理了八个开源的 Spring Boot 学习资源', 'Spring Boot 算是目前 Java 领域最火的技术栈了，松哥年初出版的 《Spring Boot + Vue 全栈开发实战》迄今为止已', 'Linux安装ftp组件(8步完成)\n\n1 安装vsftpd组件\n\n[root@bogon ~]# yum -y install vsftpd\n \n安装完后，有/etc/vsftpd/vsftpd.conf 文件，是vsftp的配置文件。\n\n2 添加一个ftp用户\n\n[root@bogon ~]# useradd ftpuser\n \n此用户就是用来登录ftp服务器用的。 \n这样一个用户建完，可以用这个登录，记得用普通登录不要用匿名了。登录后默认的路径为 /home/ftpuser.\n\n3 给ftp用户添加密码。\n\n[root@bogon ~]# passwd ftpuser\n1\n输入两次密码后修改密码。\n\n4 防火墙开启21端口\n\n因为ftp默认的端口为21，而centos默认是没有开启的，所以要修改iptables文件\n\n[root@bogon ~]# vim /etc/sysconfig/iptables\n \n在行上面有22 -j ACCEPT 下面另起一行输入跟那行差不多的，只是把22换成21，然后：wq保存。\n\n还要运行下,重启iptables\n\n[root@bogon ~]# service iptables restart\n \n5 修改selinux\n\n外网是可以访问上去了，可是发现没法返回目录（使用ftp的主动模式，被动模式还是无法访问），也上传不了，因为selinux作怪了。 \n修改selinux： \n执行以下命令查看状态：\n\n[root@bogon ~]# getsebool -a | grep ftp  \n \nallow_ftpd_anon_write –> off \nallow_ftpd_full_access –> off \nallow_ftpd_use_cifs –> off \nallow_ftpd_use_nfs –> off \nftp_home_dir –> off \nftpd_connect_db –> off \nftpd_use_passive_mode –> off \nhttpd_enable_ftp_server –> off \ntftp_anon_write –> off \n[root@bogon ~]#\n\n执行上面命令，再返回的结果看到两行都是off，代表，没有开启外网的访问\n\n[root@bogon ~]# setsebool -P allow_ftpd_full_access on\n[root@bogon ~]# setsebool -P ftp_home_dir on\n \n这样应该没问题了（如果，还是不行，看看是不是用了ftp客户端工具用了passive模式访问了，如提示Entering Passive mode，就代表是passive模式，默认是不行的，因为ftp passive模式被iptables挡住了，下面会讲怎么开启，如果懒得开的话，就看看你客户端ftp是否有port模式的选项，或者把passive模式的选项去掉。如果客户端还是不行，看看客户端上的主机的电脑是否开了防火墙，关吧）\n\nFileZilla的主动、被动模式修改： \n菜单：编辑→设置 \n这里写图片描述\n\n6 关闭匿名访问\n\n修改/etc/vsftpd/vsftpd.conf文件：\n\n[root@bogon ~]# vim /etc/vsftpd/vsftpd.conf\n \n这里写图片描述\n\n重启ftp服务：\n\n[root@bogon ~]# service vsftpd restart\n \n7 开启被动模式\n\n默认是开启的，但是要指定一个端口范围，打开vsftpd.conf文件，在后面加上\n\npasv_min_port=30000\npasv_max_port=30999\n \n \n表示端口范围为30000~30999，这个可以随意改。改完重启一下vsftpd \n由于指定这段端口范围，iptables也要相应的开启这个范围，所以像上面那样打开iptables文件。 \n也是在21上下面另起一行，更那行差不多，只是把21 改为30000:30999,然后:wq保存，重启下iptables。这样就搞定了。\n\n8 设置开机启动vsftpd ftp服务\n\n \n\n文章转载于: https://blog.csdn.net/qq_36698956\n\n版权声明：博客对我来说是记忆的笔记和知识的分享~非常感谢博客大神的帮助，若有无意侵权，请您联系我，谢谢  https://blog.csdn.net/qq_36698956\n\n[root@bogon ~]# chkconfig vsftpd on\n', NULL, '2019-06-22 13:48:56', NULL, NULL, NULL, '0', 99, 12, 0, '1', '3', 'java', '1', NULL);
INSERT INTO `tb_article` VALUES ('1142308636702412800', NULL, 'spring boot 单体项目 集成 spring security 实现 登录认证 权限认证 jwt token认证', '这篇博文讲述的是不集成oath，通过自己编写jwt 的 token 生成器 实现 spring security 的 登录权限token认证的', '本文将用代码来演示在spring boot里面，用hadoop client，通过restful API来上传文件 和下载文件 到 hadoop hdfs。\n\n里面有一些代码依赖坑，注意绕行。\n\n前提：\n\n如果你的代码在windows上运行，去连接linux上的hadoop(2.7.x或者以上），则需要做一下设置。\n\n1：下载下面的windows hadoop\n\nhttps://github.com/steveloughran/winutils/tree/master/hadoop-2.8.1\n\n在整个目录下载下来，放到一个目录下，比如 D:\\thb\\tools\\hadoop-2.8.1-bin-master，然后设置环境变量\n\nHADOOP_HOME=D:\\thb\\tools\\hadoop-2.8.1-bin-master\n\nPATH=%PATH%;%HADOOP_HOME%\n\n如何设置请自行百度一下如何在windows里面设置系统环境变量。\n\n2：pom.xml (注意hadoop-client，commons-io，commons-fileupload版本，否则编译或者运行会报错）\n\n<dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n \n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.restdocs</groupId>\n            <artifactId>spring-restdocs-mockmvc</artifactId>\n            <scope>test</scope>\n        </dependency><dependency>\n            <groupId>net.sf.json-lib</groupId>\n            <artifactId>json-lib</artifactId>\n            <version>2.4</version>\n            <classifier>jdk15</classifier>\n        </dependency>\n        <dependency>\n            <groupId>commons-fileupload</groupId>\n            <artifactId>commons-fileupload</artifactId>\n            <version>1.3.3</version>\n        </dependency>\n        <dependency>\n            <groupId>commons-io</groupId>\n            <artifactId>commons-io</artifactId>\n            <version>2.6</version>\n        </dependency>\n        <dependency>\n            <groupId>org.apache.hadoop</groupId>\n            <artifactId>hadoop-client</artifactId>\n            <version>2.7.2</version>\n        </dependency>\n    </dependencies>\n代码如下\r\n--------------------- \r\n作者：大树叶 \r\n来源：CSDN \r\n原文：https://blog.csdn.net/bigtree_3721/article/details/81713162 \r\n版权声明：本文为博主原创文章，转载请附上博文链接！', NULL, '2019-06-22 13:49:37', '2019-07-21 21:22:03', '2019-07-21 21:21:32', NULL, '0', 99, 12, 0, '1', '5', NULL, '1', NULL);
INSERT INTO `tb_article` VALUES ('1142309390188154880', NULL, 'spring boot jar部署 控制台 日志 乱码', 'spring boot jar部署 控制台 日志 乱码', '注释掉或删除\n\n4、如果，不配置logback.xml，使用默认的配置，那么部署jar包，java -jar xxx.jar，代码中log变量输出的中文，乱码；如果，配置了logback.xml，但是charset使用UTF-8，那么中文依然乱码；只有使用logback.xml，且，charset删除掉，才能确保中文正常。 \n5、针对这个非常具体的问题，我尝试过，且无用的做法有，在pom的plugin–>spring-boot-maven-plugin–>configuration节点下增加-Dfile.encoding=UTF-8，无用；或者在运行.jar包时，增加参数-Dfile.encoding=UTF-8，依然无用。\r\n \r\n作者：leondryu \r\n来源：CSDN \r\n原文：https://blog.csdn.net/leondryu/article/details/81478114 \r\n版权声明：本文为博主原创文章，转载请附上博文链接！', NULL, '2019-06-22 13:52:36', NULL, NULL, NULL, '0', 11, 0, 0, '4', '1142309252610789376', 'python', '1', NULL);
INSERT INTO `tb_article` VALUES ('1142309737099038720', NULL, '前端 UI 工程师的困境与破局', '前端的发展太快了，应该怎么去追求深度学习而不是一味追求广度？当讨论前端 UI 工程师困境的时候，会立足、', '早在 2000 年的时候我接触 PhotoShop 6.0，2003 年的时候我靠摸索做出了第一个网页，这也奠定了我的美工“出身”。我的职业生涯中有 3.5 年的时间在做 UI 相关的工作，对于这份工作优势劣势，困境与难处有些自己的见解。\n\n最近几年，在各种 JS 框架风生水起的大环境下，更是没有太多人愿意关注 UI 方面的东西，关注前端行业里这些对像素有特殊偏好的人了。我自己也有这样的趋势，当接触了更全面的研发流程之后，就很难保持对 UI 细节以及曾经追求的极致用户体验的关注度了。这或许也恰恰说明，对于某些类型的产品或某些阶段的产品来说，UI 细节没那么重要。而对于重视用户体验的用户体验设计部来说，隶属于设计部的编码人员也较难受到重视和提拔。\n\n这就是 UI 工程师的困境。我会在 2 周之内产出一篇 5000 字以上的文章，来与你共同探讨 UI 工程的困境和可能的改变方向，以及如何走出第一步的问题。\n\n实录提要：\n\n前端的发展太快了，应该怎么去追求深度学习而不是一味追求广度？\n当讨论前端 UI 工程师困境的时候，会立足以个体为主，还是以这个岗位群体为主？\n这次 512 的比特币勒索病毒会不会对前端浏览器兼容产生影响？\n怎么更好的学习应用基础布局及响应式布局？\n样式表现有问题如何调试？需要根据某些浏览器 hack，具体处理时除了经验还有什么好办法？\n后端开发者需要掌握哪些前端知识或技能？\n公司或者 leader 应该如何衡量一个偏科前端的价值呢？有比较合理的衡量标准吗？\n国内外 UI 方面有何差距？如何判断一套 UI 系统/框架的优劣？\n如何根据自身情况来针对某些东西做总结或计划？\n美的开发团队的工作方式是什么？', NULL, '2019-06-22 13:53:59', NULL, NULL, NULL, '0', 33, 32, 0, '5', '1147419061009911808', 'JS', '1', NULL);
INSERT INTO `tb_article` VALUES ('1147419057717383168', NULL, '函数作为返回值输出', '本期开始介绍 JavaScript 中的高阶函数，在 JavaScript 中，函数是一种特殊类型的对象，它们是 Function objects。那什么是高阶函数呢？本节将通过高阶函数的定义来展开介绍。', '<p>高阶函数英文叫 Higher-order function，它的定义很简单，就是至少满足下列一个条件的函数：</p><ul><li>接受一个或多个函数作为输入</li><li>输出一个函数</li></ul><p>也就是说高阶函数是对其他函数进行操作的函数，可以将它们作为参数传递，或者是返回它们。 简单来说，高阶函数是一个接收函数作为参数传递或者将函数作为返回值输出的函数。</p><h2>函数作为参数传递</h2><p>JavaScript 语言中内置了一些高阶函数，比如 Array.prototype.map，Array.prototype.filter 和 Array.prototype.reduce，它们接受一个函数作为参数，并应用这个函数到列表的每一个元素。我们来看看使用它们与不使用高阶函数的方案对比。</p><h3>Array.prototype.map</h3><p><code style=\"background-color: rgba(27, 31, 35, 0.05);\">map()</code>&nbsp;方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果，原始数组不会改变。传递给 map 的回调函数（<code style=\"background-color: rgba(27, 31, 35, 0.05);\">callback</code>）接受三个参数，分别是 currentValue、index（可选）、array（可选），除了&nbsp;<code style=\"background-color: rgba(27, 31, 35, 0.05);\">callback</code>&nbsp;之外还可以接受 this 值（可选），用于执行&nbsp;<code style=\"background-color: rgba(27, 31, 35, 0.05);\">callback</code>&nbsp;函数时使用的<code style=\"background-color: rgba(27, 31, 35, 0.05);\">this</code>&nbsp;值。</p><p>来个简单的例子方便理解，现在有一个数组&nbsp;<code style=\"background-color: rgba(27, 31, 35, 0.05);\">[1, 2, 3, 4]</code>，我们想要生成一个新数组，其每个元素皆是之前数组的两倍，那么我们有下面两种使用高阶和不使用高阶函数的方式来实现。</p><h4>不使用高阶函数</h4><pre class=\"ql-syntax\" spellcheck=\"false\">// 木易杨\nconst arr1 = [1, 2, 3, 4];\nconst arr2 = [];\nfor (let i = 0; i &lt; arr1.length; i++) {\n  arr2.push( arr1[i] * 2);\n}\n\nconsole.log( arr2 );\n// [2, 4, 6, 8]\nconsole.log( arr1 );\n// [1, 2, 3, 4]\n</pre><h4>使用高阶函数</h4><pre class=\"ql-syntax\" spellcheck=\"false\">// 木易杨\nconst arr1 = [1, 2, 3, 4];\nconst arr2 = arr1.map(item =&gt; item * 2);\n\nconsole.log( arr2 );\n// [2, 4, 6, 8]\nconsole.log( arr1 );\n// [1, 2, 3, 4]\n</pre><h3>Array.prototype.filter</h3><p><code style=\"background-color: rgba(27, 31, 35, 0.05);\">filter()</code>&nbsp;方法创建一个新数组, 其包含通过提供函数实现的测试的所有元素，原始数组不会改变。接收的参数和 map 是一样的，其返回值是一个新数组、由通过测试的所有元素组成，如果没有任何数组元素通过测试，则返回空数组。</p><p>来个例子介绍下，现在有一个数组&nbsp;<code style=\"background-color: rgba(27, 31, 35, 0.05);\">[1, 2, 1, 2, 3, 5, 4, 5, 3, 4, 4, 4, 4]</code>，我们想要生成一个新数组，这个数组要求没有重复的内容，即为去重。</p><h4>不使用高阶函数</h4><pre class=\"ql-syntax\" spellcheck=\"false\">const arr1 = [1, 2, 1, 2, 3, 5, 4, 5, 3, 4, 4, 4, 4];\nconst arr2 = [];\nfor (let i = 0; i &lt; arr1.length; i++) {\n  if (arr1.indexOf( arr1[i] ) === i) {\n    arr2.push( arr1[i] );\n  }\n}\n\nconsole.log( arr2 );\n// [1, 2, 3, 5, 4]\nconsole.log( arr1 );\n// [1, 2, 1, 2, 3, 5, 4, 5, 3, 4, 4, 4, 4]\n</pre><h4>使用高阶函数</h4><pre class=\"ql-syntax\" spellcheck=\"false\">const arr1 = [1, 2, 1, 2, 3, 5, 4, 5, 3, 4, 4, 4, 4];\nconst arr2 = arr1.filter( (element, index, self) =&gt; {\n    return self.indexOf( element ) === index;\n});\n\nconsole.log( arr2 );\n// [1, 2, 3, 5, 4]\nconsole.log( arr1 );\n// [1, 2, 1, 2, 3, 5, 4, 5, 3, 4, 4, 4, 4]\n</pre><h3>Array.prototype.reduce</h3><p><code style=\"background-color: rgba(27, 31, 35, 0.05);\">reduce()</code>&nbsp;方法对数组中的每个元素执行一个提供的&nbsp;reducer&nbsp;函数(升序执行)，将其结果汇总为单个返回值。传递给 reduce 的回调函数（<code style=\"background-color: rgba(27, 31, 35, 0.05);\">callback</code>）接受四个参数，分别是累加器 accumulator、currentValue、currentIndex（可选）、array（可选），除了&nbsp;<code style=\"background-color: rgba(27, 31, 35, 0.05);\">callback</code>&nbsp;之外还可以接受初始值 initialValue 值（可选）。</p><ul><li>如果没有提供 initialValue，那么第一次调用&nbsp;<code style=\"background-color: rgba(27, 31, 35, 0.05);\">callback</code>&nbsp;函数时，accumulator 使用原数组中的第一个元素，currentValue 即是数组中的第二个元素。 在没有初始值的空数组上调用 reduce 将报错。</li><li>如果提供了 initialValue，那么将作为第一次调用&nbsp;<code style=\"background-color: rgba(27, 31, 35, 0.05);\">callback&nbsp;</code>函数时的第一个参数的值，即 accumulator，currentValue 使用原数组中的第一个元素。</li></ul><p>来个简单的例子介绍下，现在有一个数组&nbsp;<code style=\"background-color: rgba(27, 31, 35, 0.05);\">[0, 1, 2, 3, 4]</code>，需要计算数组元素的和，需求比较简单，来看下代码实现。</p><h4>不使用高阶函数</h4><pre class=\"ql-syntax\" spellcheck=\"false\">const arr = [0, 1, 2, 3, 4];\nlet sum = 0;\nfor (let i = 0; i &lt; arr.length; i++) {\n  sum += arr[i];\n}\n\nconsole.log( sum );\n// 10\nconsole.log( arr );\n// [0, 1, 2, 3, 4]\n</pre><h4>使用高阶函数</h4><h5>无 initialValue 值</h5><pre class=\"ql-syntax\" spellcheck=\"false\">const arr = [0, 1, 2, 3, 4];\nlet sum = arr.reduce((accumulator, currentValue, currentIndex, array) =&gt; {\n  return accumulator + currentValue;\n});\n\nconsole.log( sum );\n// 10\nconsole.log( arr );\n// [0, 1, 2, 3, 4]\n</pre><p>上面是没有 initialValue 的情况，代码的执行过程如下，callback 总共调用四次。</p><p>callbackaccumulatorcurrentValuecurrentIndexarrayreturn valuefirst call011[0, 1, 2, 3, 4]1second call122[0, 1, 2, 3, 4]3third call333[0, 1, 2, 3, 4]6fourth call644[0, 1, 2, 3, 4]10</p><h5>有 initialValue 值</h5><p>我们再来看下有 initialValue 的情况，假设 initialValue 值为 10，我们看下代码。</p><pre class=\"ql-syntax\" spellcheck=\"false\">const arr = [0, 1, 2, 3, 4];\nlet sum = arr.reduce((accumulator, currentValue, currentIndex, array) =&gt; {\n  return accumulator + currentValue;\n}, 10);\n\nconsole.log( sum );\n// 20\nconsole.log( arr );\n// [0, 1, 2, 3, 4]\n</pre><p><br></p>', '高阶函数英文叫 Higher-order function，它的定义很简单，就是至少满足下列一个条件的函数：\n接受一个或多个函数作为输入\n输出一个函数\n也就是说高阶函数是对其他函数进行操作的函数，可以将它们作为参数传递，或者是返回它们。 简单来说，高阶函数是一个接收函数作为参数传递或者将函数作为返回值输出的函数。\n函数作为参数传递\nJavaScript 语言中内置了一些高阶函数，比如 Array.prototype.map，Array.prototype.filter 和 Array.prototype.reduce，它们接受一个函数作为参数，并应用这个函数到列表的每一个元素。我们来看看使用它们与不使用高阶函数的方案对比。\nArray.prototype.map\nmap() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果，原始数组不会改变。传递给 map 的回调函数（callback）接受三个参数，分别是 currentValue、index（可选）、array（可选），除了 callback 之外还可以接受 this 值（可选），用于执行 callback 函数时使用的this 值。\n来个简单的例子方便理解，现在有一个数组 [1, 2, 3, 4]，我们想要生成一个新数组，其每个元素皆是之前数组的两倍，那么我们有下面两种使用高阶和不使用高阶函数的方式来实现。\n不使用高阶函数\n// 木易杨\nconst arr1 = [1, 2, 3, 4];\nconst arr2 = [];\nfor (let i = 0; i < arr1.length; i++) {\n  arr2.push( arr1[i] * 2);\n}\n\nconsole.log( arr2 );\n// [2, 4, 6, 8]\nconsole.log( arr1 );\n// [1, 2, 3, 4]\n使用高阶函数\n// 木易杨\nconst arr1 = [1, 2, 3, 4];\nconst arr2 = arr1.map(item => item * 2);\n\nconsole.log( arr2 );\n// [2, 4, 6, 8]\nconsole.log( arr1 );\n// [1, 2, 3, 4]\nArray.prototype.filter\nfilter() 方法创建一个新数组, 其包含通过提供函数实现的测试的所有元素，原始数组不会改变。接收的参数和 map 是一样的，其返回值是一个新数组、由通过测试的所有元素组成，如果没有任何数组元素通过测试，则返回空数组。\n来个例子介绍下，现在有一个数组 [1, 2, 1, 2, 3, 5, 4, 5, 3, 4, 4, 4, 4]，我们想要生成一个新数组，这个数组要求没有重复的内容，即为去重。\n不使用高阶函数\nconst arr1 = [1, 2, 1, 2, 3, 5, 4, 5, 3, 4, 4, 4, 4];\nconst arr2 = [];\nfor (let i = 0; i < arr1.length; i++) {\n  if (arr1.indexOf( arr1[i] ) === i) {\n    arr2.push( arr1[i] );\n  }\n}\n\nconsole.log( arr2 );\n// [1, 2, 3, 5, 4]\nconsole.log( arr1 );\n// [1, 2, 1, 2, 3, 5, 4, 5, 3, 4, 4, 4, 4]\n使用高阶函数\nconst arr1 = [1, 2, 1, 2, 3, 5, 4, 5, 3, 4, 4, 4, 4];\nconst arr2 = arr1.filter( (element, index, self) => {\n    return self.indexOf( element ) === index;\n});\n\nconsole.log( arr2 );\n// [1, 2, 3, 5, 4]\nconsole.log( arr1 );\n// [1, 2, 1, 2, 3, 5, 4, 5, 3, 4, 4, 4, 4]\nArray.prototype.reduce\nreduce() 方法对数组中的每个元素执行一个提供的 reducer 函数(升序执行)，将其结果汇总为单个返回值。传递给 reduce 的回调函数（callback）接受四个参数，分别是累加器 accumulator、currentValue、currentIndex（可选）、array（可选），除了 callback 之外还可以接受初始值 initialValue 值（可选）。\n如果没有提供 initialValue，那么第一次调用 callback 函数时，accumulator 使用原数组中的第一个元素，currentValue 即是数组中的第二个元素。 在没有初始值的空数组上调用 reduce 将报错。\n如果提供了 initialValue，那么将作为第一次调用 callback 函数时的第一个参数的值，即 accumulator，currentValue 使用原数组中的第一个元素。\n来个简单的例子介绍下，现在有一个数组 [0, 1, 2, 3, 4]，需要计算数组元素的和，需求比较简单，来看下代码实现。\n不使用高阶函数\nconst arr = [0, 1, 2, 3, 4];\nlet sum = 0;\nfor (let i = 0; i < arr.length; i++) {\n  sum += arr[i];\n}\n\nconsole.log( sum );\n// 10\nconsole.log( arr );\n// [0, 1, 2, 3, 4]\n使用高阶函数\n无 initialValue 值\nconst arr = [0, 1, 2, 3, 4];\nlet sum = arr.reduce((accumulator, currentValue, currentIndex, array) => {\n  return accumulator + currentValue;\n});\n\nconsole.log( sum );\n// 10\nconsole.log( arr );\n// [0, 1, 2, 3, 4]\n上面是没有 initialValue 的情况，代码的执行过程如下，callback 总共调用四次。\ncallbackaccumulatorcurrentValuecurrentIndexarrayreturn valuefirst call011[0, 1, 2, 3, 4]1second call122[0, 1, 2, 3, 4]3third call333[0, 1, 2, 3, 4]6fourth call644[0, 1, 2, 3, 4]10\n有 initialValue 值\n我们再来看下有 initialValue 的情况，假设 initialValue 值为 10，我们看下代码。\nconst arr = [0, 1, 2, 3, 4];\nlet sum = arr.reduce((accumulator, currentValue, currentIndex, array) => {\n  return accumulator + currentValue;\n}, 10);\n\nconsole.log( sum );\n// 20\nconsole.log( arr );\n// [0, 1, 2, 3, 4]\n\n', NULL, '2019-07-06 16:16:38', NULL, NULL, NULL, 0, 0, 0, '0', '1147419061009911808', '', NULL, '1');
INSERT INTO `tb_article` VALUES ('1147422694573215744', NULL, '测试文章', '测试1232132312', '<h3>Array.prototype.map</h3><p><code style=\"background-color: rgba(27, 31, 35, 0.05);\">map()</code>&nbsp;方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果，原始数组不会改变。传递给 map 的回调函数（<code style=\"background-color: rgba(27, 31, 35, 0.05);\">callback</code>）接受三个参数，分别是 currentValue、index（可选）、array（可选），除了&nbsp;<code style=\"background-color: rgba(27, 31, 35, 0.05);\">callback</code>&nbsp;之外还可以接受 this 值（可选），用于执行&nbsp;<code style=\"background-color: rgba(27, 31, 35, 0.05);\">callback</code>&nbsp;函数时使用的<code style=\"background-color: rgba(27, 31, 35, 0.05);\">this</code>&nbsp;值。</p><p>来个简单的例子方便理解，现在有一个数组&nbsp;<code style=\"background-color: rgba(27, 31, 35, 0.05);\">[1, 2, 3, 4]</code>，我们想要生成一个新数组，其每个元素皆是之前数组的两倍，那么我们有下面两种使用高阶和不使用高阶函数的方式来实现。</p><h4>不使用高阶函数</h4><pre class=\"ql-syntax\" spellcheck=\"false\">// 木易杨\nconst arr1 = [1, 2, 3, 4];\nconst arr2 = [];\nfor (let i = 0; i &lt; arr1.length; i++) {\n  arr2.push( arr1[i] * 2);\n}\n\nconsole.log( arr2 );\n// [2, 4, 6, 8]\nconsole.log( arr1 );\n// [1, 2, 3, 4]\n</pre><h4>使用高阶函数</h4><pre class=\"ql-syntax\" spellcheck=\"false\">// 木易杨\nconst arr1 = [1, 2, 3, 4];\nconst arr2 = arr1.map(item =&gt; item * 2);\n\nconsole.log( arr2 );\n// [2, 4, 6, 8]\nconsole.log( arr1 );\n// [1, 2, 3, 4]\n</pre><h3>Array.prototype.filter</h3><p><code style=\"background-color: rgba(27, 31, 35, 0.05);\">filter()</code>&nbsp;方法创建一个新数组, 其包含通过提供函数实现的测试的所有元素，原始数组不会改变。接收的参数和 map 是一样的，其返回值是一个新数组、由通过测试的所有元素组成，如果没有任何数组元素通过测试，则返回空数组。</p><p>来个例子介绍下，现在有一个数组&nbsp;<code style=\"background-color: rgba(27, 31, 35, 0.05);\">[1, 2, 1, 2, 3, 5, 4, 5, 3, 4, 4, 4, 4]</code>，我们想要生成一个新数组，这个数组要求没有重复的内容，即为去重。</p><h4>不使用高阶函数</h4><pre class=\"ql-syntax\" spellcheck=\"false\">const arr1 = [1, 2, 1, 2, 3, 5, 4, 5, 3, 4, 4, 4, 4];\nconst arr2 = [];\nfor (let i = 0; i &lt; arr1.length; i++) {\n  if (arr1.indexOf( arr1[i] ) === i) {\n    arr2.push( arr1[i] );\n  }\n}\n\nconsole.log( arr2 );\n// [1, 2, 3, 5, 4]\nconsole.log( arr1 );\n// [1, 2, 1, 2, 3, 5, 4, 5, 3, 4, 4, 4, 4]\n</pre><h4>使用高阶函数</h4><pre class=\"ql-syntax\" spellcheck=\"false\">const arr1 = [1, 2, 1, 2, 3, 5, 4, 5, 3, 4, 4, 4, 4];\nconst arr2 = arr1.filter( (element, index, self) =&gt; {\n    return self.indexOf( element ) === index;\n});\n\nconsole.log( arr2 );\n// [1, 2, 3, 5, 4]\nconsole.log( arr1 );\n// [1, 2, 1, 2, 3, 5, 4, 5, 3, 4, 4, 4, 4]\n</pre><h3>Array.prototype.reduce</h3><p><code style=\"background-color: rgba(27, 31, 35, 0.05);\">reduce()</code>&nbsp;方法对数组中的每个元素执行一个提供的&nbsp;reducer&nbsp;函数(升序执行)，将其结果汇总为单个返回值。传递给 reduce 的回调函数（<code style=\"background-color: rgba(27, 31, 35, 0.05);\">callback</code>）接受四个参数，分别是累加器 accumulator、currentValue、currentIndex（可选）、array（可选），除了&nbsp;<code style=\"background-color: rgba(27, 31, 35, 0.05);\">callback</code>&nbsp;之外还可以接受初始值 initialValue 值（可选）。</p><ul><li>如果没有提供 initialValue，那么第一次调用&nbsp;<code style=\"background-color: rgba(27, 31, 35, 0.05);\">callback</code>&nbsp;函数时，accumulator 使用原数组中的第一个元素，currentValue 即是数组中的第二个元素。 在没有初始值的空数组上调用 reduce 将报错。</li><li>如果提供了 initialValue，那么将作为第一次调用&nbsp;<code style=\"background-color: rgba(27, 31, 35, 0.05);\">callback&nbsp;</code>函数时的第一个参数的值，即 accumulator，currentValue 使用原数组中的第一个元素。</li></ul><p>来个简单的例子介绍下，现在有一个数组&nbsp;<code style=\"background-color: rgba(27, 31, 35, 0.05);\">[0, 1, 2, 3, 4]</code>，需要计算数组元素的和，需求比较简单，来看下代码实现。</p><h4>不使用高阶函数</h4><pre class=\"ql-syntax\" spellcheck=\"false\">const arr = [0, 1, 2, 3, 4];\nlet sum = 0;\nfor (let i = 0; i &lt; arr.length; i++) {\n  sum += arr[i];\n}\n\nconsole.log( sum );\n// 10\nconsole.log( arr );\n// [0, 1, 2, 3, 4]\n</pre><h4>使用高阶函数</h4><h5>无 initialValue 值</h5><pre class=\"ql-syntax\" spellcheck=\"false\">const arr = [0, 1, 2, 3, 4];\nlet sum = arr.reduce((accumulator, currentValue, currentIndex, array) =&gt; {\n  return accumulator + currentValue;\n});\n\nconsole.log( sum );\n// 10\nconsole.log( arr );\n// [0, 1, 2, 3, 4]\n</pre><p>上面是没有 initialValue 的情况，代码的执行过程如下，callback 总共调用四次。</p><p>callbackaccumulatorcurrentValuecurrentIndexarrayreturn valuefirst call011[0, 1, 2, 3, 4]1second call122[0, 1, 2, 3, 4]3third call333[0, 1, 2, 3, 4]6fourth call644[0, 1, 2, 3, 4]10</p><h5>有 initialValue 值</h5><p>我们再来看下有 initialValue 的情况，假设 initialValue 值为 10，我们看下代码。</p><pre class=\"ql-syntax\" spellcheck=\"false\">const arr = [0, 1, 2, 3, 4];\nlet sum = arr.reduce((accumulator, currentValue, currentIndex, array) =&gt; {\n  return accumulator + currentValue;\n}, 10);\n\nconsole.log( sum );\n// 20\nconsole.log( arr );\n// [0, 1, 2, 3, 4]\n</pre><p><br></p>', 'Array.prototype.map\nmap() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果，原始数组不会改变。传递给 map 的回调函数（callback）接受三个参数，分别是 currentValue、index（可选）、array（可选），除了 callback 之外还可以接受 this 值（可选），用于执行 callback 函数时使用的this 值。\n来个简单的例子方便理解，现在有一个数组 [1, 2, 3, 4]，我们想要生成一个新数组，其每个元素皆是之前数组的两倍，那么我们有下面两种使用高阶和不使用高阶函数的方式来实现。\n不使用高阶函数\n// 木易杨\nconst arr1 = [1, 2, 3, 4];\nconst arr2 = [];\nfor (let i = 0; i < arr1.length; i++) {\n  arr2.push( arr1[i] * 2);\n}\n\nconsole.log( arr2 );\n// [2, 4, 6, 8]\nconsole.log( arr1 );\n// [1, 2, 3, 4]\n使用高阶函数\n// 木易杨\nconst arr1 = [1, 2, 3, 4];\nconst arr2 = arr1.map(item => item * 2);\n\nconsole.log( arr2 );\n// [2, 4, 6, 8]\nconsole.log( arr1 );\n// [1, 2, 3, 4]\nArray.prototype.filter\nfilter() 方法创建一个新数组, 其包含通过提供函数实现的测试的所有元素，原始数组不会改变。接收的参数和 map 是一样的，其返回值是一个新数组、由通过测试的所有元素组成，如果没有任何数组元素通过测试，则返回空数组。\n来个例子介绍下，现在有一个数组 [1, 2, 1, 2, 3, 5, 4, 5, 3, 4, 4, 4, 4]，我们想要生成一个新数组，这个数组要求没有重复的内容，即为去重。\n不使用高阶函数\nconst arr1 = [1, 2, 1, 2, 3, 5, 4, 5, 3, 4, 4, 4, 4];\nconst arr2 = [];\nfor (let i = 0; i < arr1.length; i++) {\n  if (arr1.indexOf( arr1[i] ) === i) {\n    arr2.push( arr1[i] );\n  }\n}\n\nconsole.log( arr2 );\n// [1, 2, 3, 5, 4]\nconsole.log( arr1 );\n// [1, 2, 1, 2, 3, 5, 4, 5, 3, 4, 4, 4, 4]\n使用高阶函数\nconst arr1 = [1, 2, 1, 2, 3, 5, 4, 5, 3, 4, 4, 4, 4];\nconst arr2 = arr1.filter( (element, index, self) => {\n    return self.indexOf( element ) === index;\n});\n\nconsole.log( arr2 );\n// [1, 2, 3, 5, 4]\nconsole.log( arr1 );\n// [1, 2, 1, 2, 3, 5, 4, 5, 3, 4, 4, 4, 4]\nArray.prototype.reduce\nreduce() 方法对数组中的每个元素执行一个提供的 reducer 函数(升序执行)，将其结果汇总为单个返回值。传递给 reduce 的回调函数（callback）接受四个参数，分别是累加器 accumulator、currentValue、currentIndex（可选）、array（可选），除了 callback 之外还可以接受初始值 initialValue 值（可选）。\n如果没有提供 initialValue，那么第一次调用 callback 函数时，accumulator 使用原数组中的第一个元素，currentValue 即是数组中的第二个元素。 在没有初始值的空数组上调用 reduce 将报错。\n如果提供了 initialValue，那么将作为第一次调用 callback 函数时的第一个参数的值，即 accumulator，currentValue 使用原数组中的第一个元素。\n来个简单的例子介绍下，现在有一个数组 [0, 1, 2, 3, 4]，需要计算数组元素的和，需求比较简单，来看下代码实现。\n不使用高阶函数\nconst arr = [0, 1, 2, 3, 4];\nlet sum = 0;\nfor (let i = 0; i < arr.length; i++) {\n  sum += arr[i];\n}\n\nconsole.log( sum );\n// 10\nconsole.log( arr );\n// [0, 1, 2, 3, 4]\n使用高阶函数\n无 initialValue 值\nconst arr = [0, 1, 2, 3, 4];\nlet sum = arr.reduce((accumulator, currentValue, currentIndex, array) => {\n  return accumulator + currentValue;\n});\n\nconsole.log( sum );\n// 10\nconsole.log( arr );\n// [0, 1, 2, 3, 4]\n上面是没有 initialValue 的情况，代码的执行过程如下，callback 总共调用四次。\ncallbackaccumulatorcurrentValuecurrentIndexarrayreturn valuefirst call011[0, 1, 2, 3, 4]1second call122[0, 1, 2, 3, 4]3third call333[0, 1, 2, 3, 4]6fourth call644[0, 1, 2, 3, 4]10\n有 initialValue 值\n我们再来看下有 initialValue 的情况，假设 initialValue 值为 10，我们看下代码。\nconst arr = [0, 1, 2, 3, 4];\nlet sum = arr.reduce((accumulator, currentValue, currentIndex, array) => {\n  return accumulator + currentValue;\n}, 10);\n\nconsole.log( sum );\n// 20\nconsole.log( arr );\n// [0, 1, 2, 3, 4]\n\n', 'http://132.232.104.247:9999/group1/M00/00/00/rBsACV0gXCyAa46QAADUTIre4BM964.png', '2019-07-06 16:31:05', NULL, NULL, NULL, 0, 0, 0, '0', '1147422697949630464', '测试分类', NULL, '1');
INSERT INTO `tb_article` VALUES ('1147425408644419584', NULL, '测试', '测试是十四行诗', '<p><br></p><p><img src=\"http://132.232.104.247:9999/group1/M00/00/00/rBsACV0gXlOAS4VfAATbsC2-_Bg230.jpg\"></p><p><br></p><p>测试文章的内容</p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span>()</span> {\n    System.<span class=\"hljs-keyword\">out</span>.println(<span class=\"hljs-string\">\"这是一段java代码\"</span>)  \n  }\n</pre><p><br></p><p>代码是否都可以js代码</p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">console.<span class=\"hljs-built_in\">log</span>(\'js代码输出\')\n</pre>', '\n\n\n测试文章的内容\n\npublic static void main() {\n    System.out.println(\"这是一段java代码\")  \n  }\n\n代码是否都可以js代码\n\nconsole.log(\'js代码输出\')\n', 'http://132.232.104.247:9999/group1/M00/00/00/rBsACV0gXkaAMRnIAACoXS6nses396.png', '2019-07-06 16:41:51', NULL, NULL, NULL, 0, 0, 0, '0', '1147425409953042432', '分类1', NULL, '0');
INSERT INTO `tb_article` VALUES ('1147437109494288384', NULL, 'JavaScript深入之史上最全--5种this绑定全面解析', '调用位置就是函数在代码中被调用的位置（而不是声明的位置）', '<ul><li>分析调用栈：调用位置就是当前正在执行的函数的前一个调用中</li></ul><pre class=\"ql-syntax\" spellcheck=\"false\">function baz() {\n    // 当前调用栈是：baz\n    // 因此，当前调用位置是全局作用域\n    \n    console.log( \"baz\" );\n    bar(); // &lt;-- bar的调用位置\n}\n\nfunction bar() {\n    // 当前调用栈是：baz --&gt; bar\n    // 因此，当前调用位置在baz中\n    \n    console.log( \"bar\" );\n    foo(); // &lt;-- foo的调用位置\n}\n\nfunction foo() {\n    // 当前调用栈是：baz --&gt; bar --&gt; foo\n    // 因此，当前调用位置在bar中\n    \n    console.log( \"foo\" );\n}\n\nbaz(); // &lt;-- baz的调用位置\n</pre><ul><li>使用开发者工具得到调用栈：</li><li>设置断点或者插入<code style=\"background-color: rgba(27, 31, 35, 0.05);\">debugger;</code>语句，运行时调试器会在那个位置暂停，同时展示当前位置的函数调用列表，这就是调用栈。找到栈中的第二个元素，这就是真正的调用位置。</li></ul><h4>2 绑定规则</h4><h5>2.1 默认绑定</h5><ul><li>独立函数调用，可以把默认绑定看作是无法应用其他规则时的默认规则，this指向全局对象。</li><li>严格模式下，不能将全局对象用于默认绑定，this会绑定到<code style=\"background-color: rgba(27, 31, 35, 0.05);\">undefined</code>。只有函数运行在非严格模式下，默认绑定才能绑定到全局对象。在严格模式下调用函数则不影响默认绑定。</li></ul><pre class=\"ql-syntax\" spellcheck=\"false\">function foo() { // 运行在严格模式下，this会绑定到undefined\n    \"use strict\";\n    \n    console.log( this.a );\n}\n\nvar a = 2;\n\n// 调用\nfoo(); // TypeError: Cannot read property \'a\' of undefined\n\n// --------------------------------------\n\nfunction foo() { // 运行\n    console.log( this.a );\n}\n\nvar a = 2;\n\n(function() { // 严格模式下调用函数则不影响默认绑定\n    \"use strict\";\n    \n    foo(); // 2\n})();\n</pre><h5>2.2 隐式绑定</h5><p>当函数引用有上下文对象时，隐式绑定规则会把函数中的this绑定到这个上下文对象。对象属性引用链中只有上一层或者说最后一层在调用中起作用。</p><pre class=\"ql-syntax\" spellcheck=\"false\">function foo() {\n    console.log( this.a );\n}\n\nvar obj = {\n    a: 2,\n    foo: foo\n};\n\nobj.foo(); // 2\n</pre><blockquote>隐式丢失</blockquote><p>被隐式绑定的函数特定情况下会丢失绑定对象，应用默认绑定，把this绑定到全局对象或者undefined上。</p><pre class=\"ql-syntax\" spellcheck=\"false\">// 虽然bar是obj.foo的一个引用，但是实际上，它引用的是foo函数本身。\n// bar()是一个不带任何修饰的函数调用，应用默认绑定。\nfunction foo() {\n    console.log( this.a );\n}\n\nvar obj = {\n    a: 2,\n    foo: foo\n};\n\nvar bar = obj.foo; // 函数别名\n\nvar a = \"oops, global\"; // a是全局对象的属性\n\nbar(); // \"oops, global\"\n</pre><p>参数传递就是一种隐式赋值，传入函数时也会被隐式赋值。回调函数丢失this绑定是非常常见的。</p><pre class=\"ql-syntax\" spellcheck=\"false\">function foo() {\n    console.log( this.a );\n}\n\nfunction doFoo(fn) {\n    // fn其实引用的是foo\n    \n    fn(); // &lt;-- 调用位置！\n}\n\nvar obj = {\n    a: 2,\n    foo: foo\n};\n\nvar a = \"oops, global\"; // a是全局对象的属性\n\ndoFoo( obj.foo ); // \"oops, global\"\n\n// ----------------------------------------\n\n// JS环境中内置的setTimeout()函数实现和下面的伪代码类似：\nfunction setTimeout(fn, delay) {\n    // 等待delay毫秒\n    fn(); // &lt;-- 调用位置！\n}\n</pre><h5>2.3 显式绑定</h5><p>通过<code style=\"background-color: rgba(27, 31, 35, 0.05);\">call(..)</code>&nbsp;或者&nbsp;<code style=\"background-color: rgba(27, 31, 35, 0.05);\">apply(..)</code>方法。第一个参数是一个对象，在调用函数时将这个对象绑定到this。因为直接指定this的绑定对象，称之为显示绑定。</p><pre class=\"ql-syntax\" spellcheck=\"false\">function foo() {\n    console.log( this.a );\n}\n\nvar obj = {\n    a: 2\n};\n\nfoo.call( obj ); // 2  调用foo时强制把foo的this绑定到obj上\n</pre><p>显示绑定无法解决丢失绑定问题。</p><p>解决方案：</p><ul><li>1、硬绑定</li></ul><p>创建函数bar()，并在它的内部手动调用foo.call(obj)，强制把foo的this绑定到了obj。这种方式让我想起了借用构造函数继承，没看过的可以点击查看&nbsp;<a href=\"https://juejin.im/post/5bcb2e295188255c55472db0\" target=\"_blank\" style=\"color: rgb(3, 102, 214); background-color: transparent;\">JavaScript常用八种继承方案</a></p><pre class=\"ql-syntax\" spellcheck=\"false\">function foo() {\n    console.log( this.a );\n}\n\nvar obj = {\n    a: 2\n};\n\nvar bar = function() {\n    foo.call( obj );\n};\n\nbar(); // 2\nsetTimeout( bar, 100 ); // 2\n\n// 硬绑定的bar不可能再修改它的this\nbar.call( window ); // 2\n</pre><p>典型应用场景是创建一个包裹函数，负责接收参数并返回值。</p><pre class=\"ql-syntax\" spellcheck=\"false\">function foo(something) {\n    console.log( this.a, something );\n    return this.a + something;\n}\n\nvar obj = {\n    a: 2\n};\n\nvar bar = function() {\n    return foo.apply( obj, arguments );\n};\n\nvar b = bar( 3 ); // 2 3\nconsole.log( b ); // 5\n</pre><p>创建一个可以重复使用的辅助函数。</p><pre class=\"ql-syntax\" spellcheck=\"false\">function foo(something) {\n    console.log( this.a, something );\n    return this.a + something;\n}\n\n// 简单的辅助绑定函数\nfunction bind(fn, obj) {\n    return function() {\n        return fn.apply( obj, arguments );\n    }\n}\n\nvar obj = {\n    a: 2\n};\n\nvar bar = bind( foo, obj );\n\nvar b = bar( 3 ); // 2 3\nconsole.log( b ); // 5\n</pre><p>ES5内置了<code style=\"background-color: rgba(27, 31, 35, 0.05);\">Function.prototype.bind</code>，bind会返回一个硬绑定的新函数，用法如下。</p><pre class=\"ql-syntax\" spellcheck=\"false\">function foo(something) {\n    console.log( this.a, something );\n    return this.a + something;\n}\n\nvar obj = {\n    a: 2\n};\n\nvar bar = foo.bind( obj );\n\nvar b = bar( 3 ); // 2 3\nconsole.log( b ); // 5\n</pre><ul><li>2、API调用的“上下文”</li></ul><p>JS许多内置函数提供了一个可选参数，被称之为“上下文”（context），其作用和<code style=\"background-color: rgba(27, 31, 35, 0.05);\">bind(..)</code>一样，确保回调函数使用指定的this。这些函数实际上通过<code style=\"background-color: rgba(27, 31, 35, 0.05);\">call(..)</code>和<code style=\"background-color: rgba(27, 31, 35, 0.05);\">apply(..)</code>实现了显式绑定。</p><pre class=\"ql-syntax\" spellcheck=\"false\">function foo(el) {\n	console.log( el, this.id );\n}\n\nvar obj = {\n    id: \"awesome\"\n}\n\nvar myArray = [1, 2, 3]\n// 调用foo(..)时把this绑定到obj\nmyArray.forEach( foo, obj );\n// 1 awesome 2 awesome 3 awesome\n</pre><h5>2.4 new绑定</h5><ul><li>在JS中，<code style=\"background-color: rgba(27, 31, 35, 0.05);\">构造函数</code>只是使用<code style=\"background-color: rgba(27, 31, 35, 0.05);\">new</code>操作符时被调用的<code style=\"background-color: rgba(27, 31, 35, 0.05);\">普通</code>函数，他们不属于某个类，也不会实例化一个类。</li><li>包括内置对象函数（比如<code style=\"background-color: rgba(27, 31, 35, 0.05);\">Number(..)</code>）在内的所有函数都可以用<code style=\"background-color: rgba(27, 31, 35, 0.05);\">new</code>来调用，这种函数调用被称为构造函数调用。</li><li>实际上并不存在所谓的“构造函数”，只有对于函数的“构造调用”。</li></ul><p>使用<code style=\"background-color: rgba(27, 31, 35, 0.05);\">new</code>来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。</p><ul><li>1、创建（或者说构造）一个新对象。</li><li>2、这个新对象会被执行<code style=\"background-color: rgba(27, 31, 35, 0.05);\">[[Prototype]]</code>连接。</li><li>3、这个新对象会绑定到函数调用的<code style=\"background-color: rgba(27, 31, 35, 0.05);\">this</code>。</li><li>4、如果函数没有返回其他对象，那么<code style=\"background-color: rgba(27, 31, 35, 0.05);\">new</code>表达式中的函数调用会自动返回这个新对象。</li></ul><p>使用<code style=\"background-color: rgba(27, 31, 35, 0.05);\">new</code>来调用<code style=\"background-color: rgba(27, 31, 35, 0.05);\">foo(..)</code>时，会构造一个新对象并把它（<code style=\"background-color: rgba(27, 31, 35, 0.05);\">bar</code>）绑定到<code style=\"background-color: rgba(27, 31, 35, 0.05);\">foo(..)</code>调用中的this。</p><pre class=\"ql-syntax\" spellcheck=\"false\">function foo(a) {\n    this.a = a;\n}\n\nvar bar = new foo(2); // bar和foo(..)调用中的this进行绑定\nconsole.log( bar.a ); // 2\n</pre><p>手写一个new实现</p><pre class=\"ql-syntax\" spellcheck=\"false\">function create() {\n	// 创建一个空的对象\n    var obj = new Object(),\n	// 获得构造函数，arguments中去除第一个参数\n    Con = [].shift.call(arguments);\n	// 链接到原型，obj 可以访问到构造函数原型中的属性\n    obj.__proto__ = Con.prototype;\n	// 绑定 this 实现继承，obj 可以访问到构造函数中的属性\n    var ret = Con.apply(obj, arguments);\n	// 优先返回构造函数返回的对象\n	return ret instanceof Object ? ret : obj;\n};\n</pre><p>使用这个手写的new</p><pre class=\"ql-syntax\" spellcheck=\"false\">function Person() {...}\n\n// 使用内置函数new\nvar person = new Person(...)\n                        \n// 使用手写的new，即create\nvar person = create(Person, ...)\n</pre><p>代码原理解析：</p><ul><li>1、用<code style=\"background-color: rgba(27, 31, 35, 0.05);\">new Object()&nbsp;</code>的方式新建了一个对象<code style=\"background-color: rgba(27, 31, 35, 0.05);\">obj</code></li><li>2、取出第一个参数，就是我们要传入的构造函数。此外因为 shift 会修改原数组，所以&nbsp;<code style=\"background-color: rgba(27, 31, 35, 0.05);\">arguments&nbsp;</code>会被去除第一个参数</li><li>3、将&nbsp;<code style=\"background-color: rgba(27, 31, 35, 0.05);\">obj&nbsp;</code>的原型指向构造函数，这样<code style=\"background-color: rgba(27, 31, 35, 0.05);\">obj</code>就可以访问到构造函数原型中的属性</li><li>4、使用<code style=\"background-color: rgba(27, 31, 35, 0.05);\">&nbsp;apply</code>，改变构造函数<code style=\"background-color: rgba(27, 31, 35, 0.05);\">&nbsp;this</code>&nbsp;的指向到新建的对象，这样&nbsp;<code style=\"background-color: rgba(27, 31, 35, 0.05);\">obj&nbsp;</code>就可以访问到构造函数中的属性</li><li>5、返回&nbsp;<code style=\"background-color: rgba(27, 31, 35, 0.05);\">obj</code></li></ul><h4>3 优先级</h4><pre class=\"ql-syntax\" spellcheck=\"false\">st=&gt;start: Start\ne=&gt;end: End\ncond1=&gt;condition: new绑定\nop1=&gt;operation: this绑定新创建的对象，\n				var bar = new foo()\n				\ncond2=&gt;condition: 显示绑定\nop2=&gt;operation: this绑定指定的对象，\n				var bar = foo.call(obj2)\n				\ncond3=&gt;condition: 隐式绑定\nop3=&gt;operation: this绑定上下文对象，\n				var bar = obj1.foo()\n				\nop4=&gt;operation: 默认绑定\nop5=&gt;operation: 函数体严格模式下绑定到undefined，\n				否则绑定到全局对象，\n				var bar = foo()\n\nst-&gt;cond1\ncond1(yes)-&gt;op1-&gt;e\ncond1(no)-&gt;cond2\ncond2(yes)-&gt;op2-&gt;e\ncond2(no)-&gt;cond3\ncond3(yes)-&gt;op3-&gt;e\ncond3(no)-&gt;op4-&gt;op5-&gt;e\n</pre><p>在<code style=\"background-color: rgba(27, 31, 35, 0.05);\">new</code>中使用硬绑定函数的目的是预先设置函数的一些参数，这样在使用<code style=\"background-color: rgba(27, 31, 35, 0.05);\">new</code>进行初始化时就可以只传入其余的参数（柯里化）。</p><pre class=\"ql-syntax\" spellcheck=\"false\">function foo(p1, p2) {\n    this.val = p1 + p2;\n}\n\n// 之所以使用null是因为在本例中我们并不关心硬绑定的this是什么\n// 反正使用new时this会被修改\nvar bar = foo.bind( null, \"p1\" );\n\nvar baz = new bar( \"p2\" );\n\nbaz.val; // p1p2\n</pre><h4>4 绑定例外</h4><h5>4.1 被忽略的this</h5><p>把<code style=\"background-color: rgba(27, 31, 35, 0.05);\">null</code>或者<code style=\"background-color: rgba(27, 31, 35, 0.05);\">undefined</code>作为<code style=\"background-color: rgba(27, 31, 35, 0.05);\">this</code>的绑定对象传入<code style=\"background-color: rgba(27, 31, 35, 0.05);\">call</code>、<code style=\"background-color: rgba(27, 31, 35, 0.05);\">apply</code>或者<code style=\"background-color: rgba(27, 31, 35, 0.05);\">bind</code>，这些值在调用时会被忽略，实际应用的是默认规则。</p><p>下面两种情况下会传入<code style=\"background-color: rgba(27, 31, 35, 0.05);\">null</code></p><ul><li>使用<code style=\"background-color: rgba(27, 31, 35, 0.05);\">apply(..)</code>来“展开”一个数组，并当作参数传入一个函数</li><li><code style=\"background-color: rgba(27, 31, 35, 0.05);\">bind(..)</code>可以对参数进行柯里化（预先设置一些参数）</li></ul><pre class=\"ql-syntax\" spellcheck=\"false\">function foo(a, b) {\n    console.log( \"a:\" + a + \"，b:\" + b );\n}\n\n// 把数组”展开“成参数\nfoo.apply( null, [2, 3] ); // a:2，b:3\n\n// 使用bind(..)进行柯里化\nvar bar = foo.bind( null, 2 );\nbar( 3 ); // a:2，b:3 \n</pre><p>总是传入<code style=\"background-color: rgba(27, 31, 35, 0.05);\">null</code>来忽略this绑定可能产生一些副作用。如果某个函数确实使用了this，那默认绑定规则会把this绑定到全局对象中。</p><blockquote>更安全的this</blockquote><p>安全的做法就是传入一个特殊的对象（空对象），把this绑定到这个对象不会对你的程序产生任何副作用。</p><p>JS中创建一个空对象最简单的方法是**<code style=\"background-color: rgba(27, 31, 35, 0.05);\">Object.create(null)</code>**，这个和<code style=\"background-color: rgba(27, 31, 35, 0.05);\">{}</code>很像，但是并不会创建<code style=\"background-color: rgba(27, 31, 35, 0.05);\">Object.prototype</code>这个委托，所以比<code style=\"background-color: rgba(27, 31, 35, 0.05);\">{}</code>更空。</p><pre class=\"ql-syntax\" spellcheck=\"false\">function foo(a, b) {\n    console.log( \"a:\" + a + \"，b:\" + b );\n}\n\n// 我们的空对象\nvar ø = Object.create( null );\n\n// 把数组”展开“成参数\nfoo.apply( ø, [2, 3] ); // a:2，b:3\n\n// 使用bind(..)进行柯里化\nvar bar = foo.bind( ø, 2 );\nbar( 3 ); // a:2，b:3 \n</pre><h5>4.2 间接引用</h5><p>间接引用下，调用这个函数会应用默认绑定规则。间接引用最容易在赋值时发生。</p><pre class=\"ql-syntax\" spellcheck=\"false\">// p.foo = o.foo的返回值是目标函数的引用，所以调用位置是foo()而不是p.foo()或者o.foo()\nfunction foo() {\n    console.log( this.a );\n}\n\nvar a = 2;\nvar o = { a: 3, foo: foo };\nvar p = { a: 4};\n\no.foo(); // 3\n(p.foo = o.foo)(); // 2\n</pre><h5>4.3 软绑定</h5><ul><li>硬绑定可以把this强制绑定到指定的对象（<code style=\"background-color: rgba(27, 31, 35, 0.05);\">new</code>除外），防止函数调用应用默认绑定规则。但是会降低函数的灵活性，使用硬绑定之后就无法使用隐式绑定或者显式绑定来修改this。</li><li>如果给默认绑定指定一个全局对象和undefined以外的值，那就可以实现和硬绑定相同的效果，同时保留隐式绑定或者显示绑定修改this的能力。</li></ul><pre class=\"ql-syntax\" spellcheck=\"false\">// 默认绑定规则，优先级排最后\n// 如果this绑定到全局对象或者undefined，那就把指定的默认对象obj绑定到this,否则不会修改this\nif(!Function.prototype.softBind) {\n    Function.prototype.softBind = function(obj) {\n        var fn = this;\n        // 捕获所有curried参数\n        var curried = [].slice.call( arguments, 1 ); \n        var bound = function() {\n            return fn.apply(\n            	(!this || this === (window || global)) ? \n                	obj : this,\n                curried.concat.apply( curried, arguments )\n            );\n        };\n        bound.prototype = Object.create( fn.prototype );\n        return bound;\n    };\n}\n</pre><p>使用：软绑定版本的foo()可以手动将this绑定到obj2或者obj3上，但如果应用默认绑定，则会将this绑定到obj。</p><pre class=\"ql-syntax\" spellcheck=\"false\">function foo() {\n    console.log(\"name:\" + this.name);\n}\n\nvar obj = { name: \"obj\" },\n    obj2 = { name: \"obj2\" },\n    obj3 = { name: \"obj3\" };\n\n// 默认绑定，应用软绑定，软绑定把this绑定到默认对象obj\nvar fooOBJ = foo.softBind( obj );\nfooOBJ(); // name: obj \n\n// 隐式绑定规则\nobj2.foo = foo.softBind( obj );\nobj2.foo(); // name: obj2 &lt;---- 看！！！\n\n// 显式绑定规则\nfooOBJ.call( obj3 ); // name: obj3 &lt;---- 看！！！\n\n// 绑定丢失，应用软绑定\nsetTimeout( obj2.foo, 10 ); // name: obj\n</pre><h4>5 this词法</h4><p>ES6新增一种特殊函数类型：箭头函数，箭头函数无法使用上述四条规则，而是根据外层（函数或者全局）作用域（词法作用域）来决定this。</p><ul><li><code style=\"background-color: rgba(27, 31, 35, 0.05);\">foo()</code>内部创建的箭头函数会捕获调用时<code style=\"background-color: rgba(27, 31, 35, 0.05);\">foo()</code>的this。由于<code style=\"background-color: rgba(27, 31, 35, 0.05);\">foo()</code>的this绑定到<code style=\"background-color: rgba(27, 31, 35, 0.05);\">obj1</code>，<code style=\"background-color: rgba(27, 31, 35, 0.05);\">bar</code>(引用箭头函数)的this也会绑定到<code style=\"background-color: rgba(27, 31, 35, 0.05);\">obj1</code>，箭头函数的绑定无法被修改(<code style=\"background-color: rgba(27, 31, 35, 0.05);\">new</code>也不行)。</li></ul><pre class=\"ql-syntax\" spellcheck=\"false\">function foo() {\n    // 返回一个箭头函数\n    return (a) =&gt; {\n        // this继承自foo()\n        console.log( this.a );\n    };\n}\n\nvar obj1 = {\n    a: 2\n};\n\nvar obj2 = {\n    a: 3\n}\n\nvar bar = foo.call( obj1 );\nbar.call( obj2 ); // 2，不是3！\n</pre><p>ES6之前和箭头函数类似的模式，采用的是词法作用域取代了传统的this机制。</p><pre class=\"ql-syntax\" spellcheck=\"false\">function foo() {\n    var self = this; // lexical capture of this\n    setTimeout( function() {\n        console.log( self.a ); // self只是继承了foo()函数的this绑定\n    }, 100 );\n}\n\nvar obj = {\n    a: 2\n};\n\nfoo.call(obj); // 2\n</pre><p>代码风格统一问题：如果既有this风格的代码，还会使用&nbsp;<code style=\"background-color: rgba(27, 31, 35, 0.05);\">seft = this</code>&nbsp;或者箭头函数来否定this机制。</p><ul><li>只使用词法作用域并完全抛弃错误this风格的代码；</li><li>完全采用this风格，在必要时使用<code style=\"background-color: rgba(27, 31, 35, 0.05);\">bind(..)</code>，尽量避免使用&nbsp;<code style=\"background-color: rgba(27, 31, 35, 0.05);\">self = this</code>&nbsp;和箭头函数。</li></ul><h4>上期思考题解</h4><p>代码1：</p><pre class=\"ql-syntax\" spellcheck=\"false\">var scope = \"global scope\";\nfunction checkscope(){\n    var scope = \"local scope\";\n    function f(){\n        return scope;\n    }\n    return f;\n}\n\ncheckscope()();                  \n</pre><p>代码2：</p><pre class=\"ql-syntax\" spellcheck=\"false\">var scope = \"global scope\";\nfunction checkscope(){\n    var scope = \"local scope\";\n    function f(){\n        return scope;\n    }\n    return f;\n}\n\nvar foo = checkscope(); \nfoo();    \n</pre><p>上面的两个代码中，<code style=\"background-color: rgba(27, 31, 35, 0.05);\">checkscope()</code>执行完成后，闭包<code style=\"background-color: rgba(27, 31, 35, 0.05);\">f</code>所引用的自由变量<code style=\"background-color: rgba(27, 31, 35, 0.05);\">scope</code>会被垃圾回收吗？为什么？</p><p>解答：</p><p><code style=\"background-color: rgba(27, 31, 35, 0.05);\">checkscope()</code>执行完成后，代码1中自由变量特定时间之后回收，代码2中自由变量不回收。</p><p>首先要说明的是，现在主流浏览器的垃圾回收算法是标记清除，标记清除并非是标记执行栈的进出，而是从根开始遍历，也是一个找引用关系的过程，但是因为从根开始，相互引用的情况不会被计入。所以当垃圾回收开始时，从Root（全局对象）开始寻找这个对象的引用是否可达，如果引用链断裂，那么这个对象就会回收。</p><p>闭包中的作用域链中 parentContext.vo 是对象，被放在堆中，栈中的变量会随着执行环境进出而销毁，堆中需要垃圾回收，闭包内的自由变量会被分配到堆上，所以当外部方法执行完毕后，对其的引用并没有丢。</p><p>每次进入函数执行时，会重新创建可执行环境和活动对象，但函数的<code style=\"background-color: rgba(27, 31, 35, 0.05);\">[[Scope]]</code>是函数定义时就已经定义好的（词法作用域规则），不可更改。</p><ul><li>对于代码1：</li></ul><p><code style=\"background-color: rgba(27, 31, 35, 0.05);\">checkscope()</code>执行时,将<code style=\"background-color: rgba(27, 31, 35, 0.05);\">checkscope</code>对象指针压入栈中，其执行环境变量如下</p><pre class=\"ql-syntax\" spellcheck=\"false\">checkscopeContext:{\n    AO:{\n        arguments:\n        scope:\n        f:\n    },\n    this,\n    [[Scope]]:[AO, globalContext.VO]\n}\n</pre><p>执行完毕后出栈，该对象没有绑定给谁，从Root开始查找无法可达，此活动对象一段时间后会被回收</p><ul><li>对于代码2：</li></ul><p><code style=\"background-color: rgba(27, 31, 35, 0.05);\">checkscope()</code>执行后，返回的是<code style=\"background-color: rgba(27, 31, 35, 0.05);\">f</code>对象，其执行环境变量如下</p><pre class=\"ql-syntax\" spellcheck=\"false\">fContext:{\n    AO:{\n        arguments:\n    },\n    this,\n    [[Scope]]:[AO, checkscopeContext.AO, globalContext.VO]\n}\n</pre><p>此对象赋值给<code style=\"background-color: rgba(27, 31, 35, 0.05);\">var foo = checkscope();</code>，将<code style=\"background-color: rgba(27, 31, 35, 0.05);\">foo&nbsp;</code>压入栈中，<code style=\"background-color: rgba(27, 31, 35, 0.05);\">foo&nbsp;</code>指向堆中的<code style=\"background-color: rgba(27, 31, 35, 0.05);\">f</code>活动对象,对于<code style=\"background-color: rgba(27, 31, 35, 0.05);\">Root</code>来说可达，不会被回收。</p><p>如果一定要自由变量<code style=\"background-color: rgba(27, 31, 35, 0.05);\">scope</code>回收，那么该怎么办？？？</p><p>很简单，<code style=\"background-color: rgba(27, 31, 35, 0.05);\">foo = null;</code>，把引用断开就可以了。</p><h4>本期思考题</h4><p>依次给出console.log输出的数值。</p><pre class=\"ql-syntax\" spellcheck=\"false\">var num = 1;\nvar myObject = {\n    num: 2,\n    add: function() {\n        this.num = 3;\n        (function() {\n            console.log(this.num);\n            this.num = 4;\n        })();\n        console.log(this.num);\n    },\n    sub: function() {\n        console.log(this.num)\n    }\n}\nmyObject.add();\nconsole.log(myObject.num);\nconsole.log(num);\nvar sub = myObject.sub;\nsub();\n</pre><p><br></p>', '分析调用栈：调用位置就是当前正在执行的函数的前一个调用中\nfunction baz() {\n    // 当前调用栈是：baz\n    // 因此，当前调用位置是全局作用域\n    \n    console.log( \"baz\" );\n    bar(); // <-- bar的调用位置\n}\n\nfunction bar() {\n    // 当前调用栈是：baz --> bar\n    // 因此，当前调用位置在baz中\n    \n    console.log( \"bar\" );\n    foo(); // <-- foo的调用位置\n}\n\nfunction foo() {\n    // 当前调用栈是：baz --> bar --> foo\n    // 因此，当前调用位置在bar中\n    \n    console.log( \"foo\" );\n}\n\nbaz(); // <-- baz的调用位置\n使用开发者工具得到调用栈：\n设置断点或者插入debugger;语句，运行时调试器会在那个位置暂停，同时展示当前位置的函数调用列表，这就是调用栈。找到栈中的第二个元素，这就是真正的调用位置。\n2 绑定规则\n2.1 默认绑定\n独立函数调用，可以把默认绑定看作是无法应用其他规则时的默认规则，this指向全局对象。\n严格模式下，不能将全局对象用于默认绑定，this会绑定到undefined。只有函数运行在非严格模式下，默认绑定才能绑定到全局对象。在严格模式下调用函数则不影响默认绑定。\nfunction foo() { // 运行在严格模式下，this会绑定到undefined\n    \"use strict\";\n    \n    console.log( this.a );\n}\n\nvar a = 2;\n\n// 调用\nfoo(); // TypeError: Cannot read property \'a\' of undefined\n\n// --------------------------------------\n\nfunction foo() { // 运行\n    console.log( this.a );\n}\n\nvar a = 2;\n\n(function() { // 严格模式下调用函数则不影响默认绑定\n    \"use strict\";\n    \n    foo(); // 2\n})();\n2.2 隐式绑定\n当函数引用有上下文对象时，隐式绑定规则会把函数中的this绑定到这个上下文对象。对象属性引用链中只有上一层或者说最后一层在调用中起作用。\nfunction foo() {\n    console.log( this.a );\n}\n\nvar obj = {\n    a: 2,\n    foo: foo\n};\n\nobj.foo(); // 2\n隐式丢失\n被隐式绑定的函数特定情况下会丢失绑定对象，应用默认绑定，把this绑定到全局对象或者undefined上。\n// 虽然bar是obj.foo的一个引用，但是实际上，它引用的是foo函数本身。\n// bar()是一个不带任何修饰的函数调用，应用默认绑定。\nfunction foo() {\n    console.log( this.a );\n}\n\nvar obj = {\n    a: 2,\n    foo: foo\n};\n\nvar bar = obj.foo; // 函数别名\n\nvar a = \"oops, global\"; // a是全局对象的属性\n\nbar(); // \"oops, global\"\n参数传递就是一种隐式赋值，传入函数时也会被隐式赋值。回调函数丢失this绑定是非常常见的。\nfunction foo() {\n    console.log( this.a );\n}\n\nfunction doFoo(fn) {\n    // fn其实引用的是foo\n    \n    fn(); // <-- 调用位置！\n}\n\nvar obj = {\n    a: 2,\n    foo: foo\n};\n\nvar a = \"oops, global\"; // a是全局对象的属性\n\ndoFoo( obj.foo ); // \"oops, global\"\n\n// ----------------------------------------\n\n// JS环境中内置的setTimeout()函数实现和下面的伪代码类似：\nfunction setTimeout(fn, delay) {\n    // 等待delay毫秒\n    fn(); // <-- 调用位置！\n}\n2.3 显式绑定\n通过call(..) 或者 apply(..)方法。第一个参数是一个对象，在调用函数时将这个对象绑定到this。因为直接指定this的绑定对象，称之为显示绑定。\nfunction foo() {\n    console.log( this.a );\n}\n\nvar obj = {\n    a: 2\n};\n\nfoo.call( obj ); // 2  调用foo时强制把foo的this绑定到obj上\n显示绑定无法解决丢失绑定问题。\n解决方案：\n1、硬绑定\n创建函数bar()，并在它的内部手动调用foo.call(obj)，强制把foo的this绑定到了obj。这种方式让我想起了借用构造函数继承，没看过的可以点击查看 JavaScript常用八种继承方案\nfunction foo() {\n    console.log( this.a );\n}\n\nvar obj = {\n    a: 2\n};\n\nvar bar = function() {\n    foo.call( obj );\n};\n\nbar(); // 2\nsetTimeout( bar, 100 ); // 2\n\n// 硬绑定的bar不可能再修改它的this\nbar.call( window ); // 2\n典型应用场景是创建一个包裹函数，负责接收参数并返回值。\nfunction foo(something) {\n    console.log( this.a, something );\n    return this.a + something;\n}\n\nvar obj = {\n    a: 2\n};\n\nvar bar = function() {\n    return foo.apply( obj, arguments );\n};\n\nvar b = bar( 3 ); // 2 3\nconsole.log( b ); // 5\n创建一个可以重复使用的辅助函数。\nfunction foo(something) {\n    console.log( this.a, something );\n    return this.a + something;\n}\n\n// 简单的辅助绑定函数\nfunction bind(fn, obj) {\n    return function() {\n        return fn.apply( obj, arguments );\n    }\n}\n\nvar obj = {\n    a: 2\n};\n\nvar bar = bind( foo, obj );\n\nvar b = bar( 3 ); // 2 3\nconsole.log( b ); // 5\nES5内置了Function.prototype.bind，bind会返回一个硬绑定的新函数，用法如下。\nfunction foo(something) {\n    console.log( this.a, something );\n    return this.a + something;\n}\n\nvar obj = {\n    a: 2\n};\n\nvar bar = foo.bind( obj );\n\nvar b = bar( 3 ); // 2 3\nconsole.log( b ); // 5\n2、API调用的“上下文”\nJS许多内置函数提供了一个可选参数，被称之为“上下文”（context），其作用和bind(..)一样，确保回调函数使用指定的this。这些函数实际上通过call(..)和apply(..)实现了显式绑定。\nfunction foo(el) {\n	console.log( el, this.id );\n}\n\nvar obj = {\n    id: \"awesome\"\n}\n\nvar myArray = [1, 2, 3]\n// 调用foo(..)时把this绑定到obj\nmyArray.forEach( foo, obj );\n// 1 awesome 2 awesome 3 awesome\n2.4 new绑定\n在JS中，构造函数只是使用new操作符时被调用的普通函数，他们不属于某个类，也不会实例化一个类。\n包括内置对象函数（比如Number(..)）在内的所有函数都可以用new来调用，这种函数调用被称为构造函数调用。\n实际上并不存在所谓的“构造函数”，只有对于函数的“构造调用”。\n使用new来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。\n1、创建（或者说构造）一个新对象。\n2、这个新对象会被执行[[Prototype]]连接。\n3、这个新对象会绑定到函数调用的this。\n4、如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。\n使用new来调用foo(..)时，会构造一个新对象并把它（bar）绑定到foo(..)调用中的this。\nfunction foo(a) {\n    this.a = a;\n}\n\nvar bar = new foo(2); // bar和foo(..)调用中的this进行绑定\nconsole.log( bar.a ); // 2\n手写一个new实现\nfunction create() {\n	// 创建一个空的对象\n    var obj = new Object(),\n	// 获得构造函数，arguments中去除第一个参数\n    Con = [].shift.call(arguments);\n	// 链接到原型，obj 可以访问到构造函数原型中的属性\n    obj.__proto__ = Con.prototype;\n	// 绑定 this 实现继承，obj 可以访问到构造函数中的属性\n    var ret = Con.apply(obj, arguments);\n	// 优先返回构造函数返回的对象\n	return ret instanceof Object ? ret : obj;\n};\n使用这个手写的new\nfunction Person() {...}\n\n// 使用内置函数new\nvar person = new Person(...)\n                        \n// 使用手写的new，即create\nvar person = create(Person, ...)\n代码原理解析：\n1、用new Object() 的方式新建了一个对象obj\n2、取出第一个参数，就是我们要传入的构造函数。此外因为 shift 会修改原数组，所以 arguments 会被去除第一个参数\n3、将 obj 的原型指向构造函数，这样obj就可以访问到构造函数原型中的属性\n4、使用 apply，改变构造函数 this 的指向到新建的对象，这样 obj 就可以访问到构造函数中的属性\n5、返回 obj\n3 优先级\nst=>start: Start\ne=>end: End\ncond1=>condition: new绑定\nop1=>operation: this绑定新创建的对象，\n				var bar = new foo()\n				\ncond2=>condition: 显示绑定\nop2=>operation: this绑定指定的对象，\n				var bar = foo.call(obj2)\n				\ncond3=>condition: 隐式绑定\nop3=>operation: this绑定上下文对象，\n				var bar = obj1.foo()\n				\nop4=>operation: 默认绑定\nop5=>operation: 函数体严格模式下绑定到undefined，\n				否则绑定到全局对象，\n				var bar = foo()\n\nst->cond1\ncond1(yes)->op1->e\ncond1(no)->cond2\ncond2(yes)->op2->e\ncond2(no)->cond3\ncond3(yes)->op3->e\ncond3(no)->op4->op5->e\n在new中使用硬绑定函数的目的是预先设置函数的一些参数，这样在使用new进行初始化时就可以只传入其余的参数（柯里化）。\nfunction foo(p1, p2) {\n    this.val = p1 + p2;\n}\n\n// 之所以使用null是因为在本例中我们并不关心硬绑定的this是什么\n// 反正使用new时this会被修改\nvar bar = foo.bind( null, \"p1\" );\n\nvar baz = new bar( \"p2\" );\n\nbaz.val; // p1p2\n4 绑定例外\n4.1 被忽略的this\n把null或者undefined作为this的绑定对象传入call、apply或者bind，这些值在调用时会被忽略，实际应用的是默认规则。\n下面两种情况下会传入null\n使用apply(..)来“展开”一个数组，并当作参数传入一个函数\nbind(..)可以对参数进行柯里化（预先设置一些参数）\nfunction foo(a, b) {\n    console.log( \"a:\" + a + \"，b:\" + b );\n}\n\n// 把数组”展开“成参数\nfoo.apply( null, [2, 3] ); // a:2，b:3\n\n// 使用bind(..)进行柯里化\nvar bar = foo.bind( null, 2 );\nbar( 3 ); // a:2，b:3 \n总是传入null来忽略this绑定可能产生一些副作用。如果某个函数确实使用了this，那默认绑定规则会把this绑定到全局对象中。\n更安全的this\n安全的做法就是传入一个特殊的对象（空对象），把this绑定到这个对象不会对你的程序产生任何副作用。\nJS中创建一个空对象最简单的方法是**Object.create(null)**，这个和{}很像，但是并不会创建Object.prototype这个委托，所以比{}更空。\nfunction foo(a, b) {\n    console.log( \"a:\" + a + \"，b:\" + b );\n}\n\n// 我们的空对象\nvar ø = Object.create( null );\n\n// 把数组”展开“成参数\nfoo.apply( ø, [2, 3] ); // a:2，b:3\n\n// 使用bind(..)进行柯里化\nvar bar = foo.bind( ø, 2 );\nbar( 3 ); // a:2，b:3 \n4.2 间接引用\n间接引用下，调用这个函数会应用默认绑定规则。间接引用最容易在赋值时发生。\n// p.foo = o.foo的返回值是目标函数的引用，所以调用位置是foo()而不是p.foo()或者o.foo()\nfunction foo() {\n    console.log( this.a );\n}\n\nvar a = 2;\nvar o = { a: 3, foo: foo };\nvar p = { a: 4};\n\no.foo(); // 3\n(p.foo = o.foo)(); // 2\n4.3 软绑定\n硬绑定可以把this强制绑定到指定的对象（new除外），防止函数调用应用默认绑定规则。但是会降低函数的灵活性，使用硬绑定之后就无法使用隐式绑定或者显式绑定来修改this。\n如果给默认绑定指定一个全局对象和undefined以外的值，那就可以实现和硬绑定相同的效果，同时保留隐式绑定或者显示绑定修改this的能力。\n// 默认绑定规则，优先级排最后\n// 如果this绑定到全局对象或者undefined，那就把指定的默认对象obj绑定到this,否则不会修改this\nif(!Function.prototype.softBind) {\n    Function.prototype.softBind = function(obj) {\n        var fn = this;\n        // 捕获所有curried参数\n        var curried = [].slice.call( arguments, 1 ); \n        var bound = function() {\n            return fn.apply(\n            	(!this || this === (window || global)) ? \n                	obj : this,\n                curried.concat.apply( curried, arguments )\n            );\n        };\n        bound.prototype = Object.create( fn.prototype );\n        return bound;\n    };\n}\n使用：软绑定版本的foo()可以手动将this绑定到obj2或者obj3上，但如果应用默认绑定，则会将this绑定到obj。\nfunction foo() {\n    console.log(\"name:\" + this.name);\n}\n\nvar obj = { name: \"obj\" },\n    obj2 = { name: \"obj2\" },\n    obj3 = { name: \"obj3\" };\n\n// 默认绑定，应用软绑定，软绑定把this绑定到默认对象obj\nvar fooOBJ = foo.softBind( obj );\nfooOBJ(); // name: obj \n\n// 隐式绑定规则\nobj2.foo = foo.softBind( obj );\nobj2.foo(); // name: obj2 <---- 看！！！\n\n// 显式绑定规则\nfooOBJ.call( obj3 ); // name: obj3 <---- 看！！！\n\n// 绑定丢失，应用软绑定\nsetTimeout( obj2.foo, 10 ); // name: obj\n5 this词法\nES6新增一种特殊函数类型：箭头函数，箭头函数无法使用上述四条规则，而是根据外层（函数或者全局）作用域（词法作用域）来决定this。\nfoo()内部创建的箭头函数会捕获调用时foo()的this。由于foo()的this绑定到obj1，bar(引用箭头函数)的this也会绑定到obj1，箭头函数的绑定无法被修改(new也不行)。\nfunction foo() {\n    // 返回一个箭头函数\n    return (a) => {\n        // this继承自foo()\n        console.log( this.a );\n    };\n}\n\nvar obj1 = {\n    a: 2\n};\n\nvar obj2 = {\n    a: 3\n}\n\nvar bar = foo.call( obj1 );\nbar.call( obj2 ); // 2，不是3！\nES6之前和箭头函数类似的模式，采用的是词法作用域取代了传统的this机制。\nfunction foo() {\n    var self = this; // lexical capture of this\n    setTimeout( function() {\n        console.log( self.a ); // self只是继承了foo()函数的this绑定\n    }, 100 );\n}\n\nvar obj = {\n    a: 2\n};\n\nfoo.call(obj); // 2\n代码风格统一问题：如果既有this风格的代码，还会使用 seft = this 或者箭头函数来否定this机制。\n只使用词法作用域并完全抛弃错误this风格的代码；\n完全采用this风格，在必要时使用bind(..)，尽量避免使用 self = this 和箭头函数。\n上期思考题解\n代码1：\nvar scope = \"global scope\";\nfunction checkscope(){\n    var scope = \"local scope\";\n    function f(){\n        return scope;\n    }\n    return f;\n}\n\ncheckscope()();                  \n代码2：\nvar scope = \"global scope\";\nfunction checkscope(){\n    var scope = \"local scope\";\n    function f(){\n        return scope;\n    }\n    return f;\n}\n\nvar foo = checkscope(); \nfoo();    \n上面的两个代码中，checkscope()执行完成后，闭包f所引用的自由变量scope会被垃圾回收吗？为什么？\n解答：\ncheckscope()执行完成后，代码1中自由变量特定时间之后回收，代码2中自由变量不回收。\n首先要说明的是，现在主流浏览器的垃圾回收算法是标记清除，标记清除并非是标记执行栈的进出，而是从根开始遍历，也是一个找引用关系的过程，但是因为从根开始，相互引用的情况不会被计入。所以当垃圾回收开始时，从Root（全局对象）开始寻找这个对象的引用是否可达，如果引用链断裂，那么这个对象就会回收。\n闭包中的作用域链中 parentContext.vo 是对象，被放在堆中，栈中的变量会随着执行环境进出而销毁，堆中需要垃圾回收，闭包内的自由变量会被分配到堆上，所以当外部方法执行完毕后，对其的引用并没有丢。\n每次进入函数执行时，会重新创建可执行环境和活动对象，但函数的[[Scope]]是函数定义时就已经定义好的（词法作用域规则），不可更改。\n对于代码1：\ncheckscope()执行时,将checkscope对象指针压入栈中，其执行环境变量如下\ncheckscopeContext:{\n    AO:{\n        arguments:\n        scope:\n        f:\n    },\n    this,\n    [[Scope]]:[AO, globalContext.VO]\n}\n执行完毕后出栈，该对象没有绑定给谁，从Root开始查找无法可达，此活动对象一段时间后会被回收\n对于代码2：\ncheckscope()执行后，返回的是f对象，其执行环境变量如下\nfContext:{\n    AO:{\n        arguments:\n    },\n    this,\n    [[Scope]]:[AO, checkscopeContext.AO, globalContext.VO]\n}\n此对象赋值给var foo = checkscope();，将foo 压入栈中，foo 指向堆中的f活动对象,对于Root来说可达，不会被回收。\n如果一定要自由变量scope回收，那么该怎么办？？？\n很简单，foo = null;，把引用断开就可以了。\n本期思考题\n依次给出console.log输出的数值。\nvar num = 1;\nvar myObject = {\n    num: 2,\n    add: function() {\n        this.num = 3;\n        (function() {\n            console.log(this.num);\n            this.num = 4;\n        })();\n        console.log(this.num);\n    },\n    sub: function() {\n        console.log(this.num)\n    }\n}\nmyObject.add();\nconsole.log(myObject.num);\nconsole.log(num);\nvar sub = myObject.sub;\nsub();\n\n', 'http://132.232.104.247:9999/group1/M00/00/00/rBsACV0gaViACv1GAAFmQSzH81U392.png', '2019-07-06 17:28:22', NULL, '1', '0', 0, 0, 0, '0', '1147437111490777088', '分类123', 'http://132.232.104.247/#/blog/1147437109494288384', '0');
INSERT INTO `tb_article` VALUES ('1147446159820853248', NULL, '123', '321', '<p>11111111</p>', '11111111\n', '', '2019-07-06 18:04:19', NULL, '1', '0', 0, 0, 0, '0', '1', '', 'http://132.232.104.247/#/blog/1147446159820853248', '0');
INSERT INTO `tb_article` VALUES ('1147449716045385728', NULL, '12321', '111111', '<h4>期思考题</h4><p>依次给出console.log输出的数值。</p><pre class=\"ql-syntax\" spellcheck=\"false\"><span class=\"hljs-keyword\">var</span> num = <span class=\"hljs-number\">1</span>;\n<span class=\"hljs-keyword\">var</span> myObject = {\n    <span class=\"hljs-attr\">num</span>: <span class=\"hljs-number\">2</span>,\n    <span class=\"hljs-attr\">add</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>() </span>{\n        <span class=\"hljs-keyword\">this</span>.num = <span class=\"hljs-number\">3</span>;\n        (<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>() </span>{\n            <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>.num);\n            <span class=\"hljs-keyword\">this</span>.num = <span class=\"hljs-number\">4</span>;\n        })();\n        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>.num);\n    },\n    <span class=\"hljs-attr\">sub</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>() </span>{\n        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>.num)\n    }\n}\nmyObject.add();\n<span class=\"hljs-built_in\">console</span>.log(myObject.num);\n<span class=\"hljs-built_in\">console</span>.log(num);\n<span class=\"hljs-keyword\">var</span> sub = myObject.sub;\nsub();\n</pre><h4>参考</h4><blockquote><a href=\"https://github.com/yygmind/Reading-Notes/blob/master/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript%E4%B8%8A%E5%8D%B7.md\" target=\"_blank\" style=\"color: rgb(3, 102, 214); background-color: transparent;\">你不知道的JavaScript上卷—笔记</a></blockquote><blockquote><a href=\"https://www.zhihu.com/question/40678847/answer/87982345\" target=\"_blank\" style=\"color: rgb(3, 102, 214); background-color: transparent;\">Javascript 闭包，引用的变量是否被回收？</a></blockquote><h4>进阶系列目录</h4><ul><li>【进阶1期】 调用堆栈</li><li>【进阶2期】 作用域闭包</li><li>【进阶3期】 this全面解析</li><li>【进阶4期】 深浅拷贝原理</li><li>【进阶5期】 原型Prototype</li><li>【进阶6期】 高阶函数</li><li>【进阶7期】 事件机制</li><li>【进阶8期】 Event Loop原理</li><li>【进阶9期】 Promise原理</li><li>【进阶10期】Async/Await原理</li><li>【进阶11期】防抖/节流原理</li><li>【进阶12期】模块化详解</li><li>【进阶13期】ES6重难点</li><li>【进阶14期】计算机网络概述</li><li>【进阶15期】浏览器渲染原理</li><li>【进阶16期】webpack配置</li><li>【进阶17期】webpack原理</li><li>【进阶18期】前端监控</li><li>【进阶19期】跨域和安全</li><li>【进阶20期】性能优化</li><li>【进阶21期】VirtualDom原理</li><li>【进阶22期】Diff算法</li><li>【进阶23期】MVVM双向绑定</li><li>【进阶24期】Vuex原理</li><li>【进阶25期】Redux原理</li><li>【进阶26期】路由原理</li><li>【进阶27期】VueRouter源码解析</li><li>【进阶28期】ReactRouter源码解析</li></ul><h4>交流</h4><p>进阶系列文章汇总如下，内有优质前端资料，觉得不错点个star。</p><blockquote><a href=\"https://github.com/yygmind/blog\" target=\"_blank\" style=\"color: rgb(3, 102, 214); background-color: transparent;\">https://github.com/yygmind/blog</a></blockquote><p>我是木易杨，网易高级前端工程师，跟着我每周重点攻克一个前端面试重难点。接下来让我带你走进高级前端的世界，在进阶的路上，共勉！</p><p><a href=\"https://github.com/yygmind/blog/raw/master/images/weixin_re.png\" target=\"_blank\" style=\"color: rgb(3, 102, 214); background-color: transparent;\"><img src=\"https://github.com/yygmind/blog/raw/master/images/weixin_re.png\" width=\"436\" style=\"cursor: nesw-resize;\"></a></p>', '期思考题\n依次给出console.log输出的数值。\nvar num = 1;\nvar myObject = {\n    num: 2,\n    add: function() {\n        this.num = 3;\n        (function() {\n            console.log(this.num);\n            this.num = 4;\n        })();\n        console.log(this.num);\n    },\n    sub: function() {\n        console.log(this.num)\n    }\n}\nmyObject.add();\nconsole.log(myObject.num);\nconsole.log(num);\nvar sub = myObject.sub;\nsub();\n参考\n你不知道的JavaScript上卷—笔记\nJavascript 闭包，引用的变量是否被回收？\n进阶系列目录\n【进阶1期】 调用堆栈\n【进阶2期】 作用域闭包\n【进阶3期】 this全面解析\n【进阶4期】 深浅拷贝原理\n【进阶5期】 原型Prototype\n【进阶6期】 高阶函数\n【进阶7期】 事件机制\n【进阶8期】 Event Loop原理\n【进阶9期】 Promise原理\n【进阶10期】Async/Await原理\n【进阶11期】防抖/节流原理\n【进阶12期】模块化详解\n【进阶13期】ES6重难点\n【进阶14期】计算机网络概述\n【进阶15期】浏览器渲染原理\n【进阶16期】webpack配置\n【进阶17期】webpack原理\n【进阶18期】前端监控\n【进阶19期】跨域和安全\n【进阶20期】性能优化\n【进阶21期】VirtualDom原理\n【进阶22期】Diff算法\n【进阶23期】MVVM双向绑定\n【进阶24期】Vuex原理\n【进阶25期】Redux原理\n【进阶26期】路由原理\n【进阶27期】VueRouter源码解析\n【进阶28期】ReactRouter源码解析\n交流\n进阶系列文章汇总如下，内有优质前端资料，觉得不错点个star。\nhttps://github.com/yygmind/blog\n我是木易杨，网易高级前端工程师，跟着我每周重点攻克一个前端面试重难点。接下来让我带你走进高级前端的世界，在进阶的路上，共勉！\n\n', 'http://132.232.104.247:9999/group1/M00/00/00/rBsACV0gdSuAfWFwAANKaIY5CUs968.png', '2019-07-06 18:18:26', NULL, '1', '0', 0, 0, 0, '0', '5', '', 'http://132.232.104.247/#/blog/1147449716045385728', '0');
INSERT INTO `tb_article` VALUES ('1149887336700579840', NULL, '测试123', '1233211232123', '<p>测试123321</p><pre class=\"ql-syntax\" spellcheck=\"false\">console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-number\">123</span>)\n</pre><p><br></p>', '测试123321\nconsole.log(123)\n\n', 'http://132.232.104.247:9999/group1/M00/00/00/rBsACV0pU36AcNjvAADnbSJ_EYQ784.jpg', '2019-07-13 11:44:40', NULL, '1', '0', 0, 0, 0, '0', '1147422697949630464', '', 'http://132.232.104.247/#/blog/1149887336700579840', '0');
INSERT INTO `tb_article` VALUES ('1149927249663889408', NULL, '这是一个markdown标题', '这是系统的摘要', '<p>这是一个markdown的编辑器写出来的内容，是否可以直接使用呢，下面是sublime的代码</p>\n<pre><div class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>\n<span class=\"hljs-keyword\">const</span> j = <span class=\"hljs-number\">0</span> \n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n   i++ \n  <span class=\"hljs-keyword\">if</span>(i = j){\n   <span class=\"hljs-built_in\">console</span>.log(i)\n}\n\n}\n\n</code></div></pre>\n<p>这是代码片段<code>code style</code></p>\n<blockquote>\n<p>这是引用</p>\n</blockquote>\n<hr />\n', '这是一个markdown的编辑器写出来的内容，是否可以直接使用呢，下面是sublime的代码\n\n```js\nlet i = 0\nconst j = 0 \nfunction() {\n   i++ \n  if(i = j){\n   console.log(i)\n}\n\n}\n\n```\n\n这是代码片段`code style`\n> 这是引用\n\n----- ', 'http://132.232.104.247:9999/group1/M00/00/00/rBsACV0pd5mAZPKPAAOn6JA93PY118.png', '2019-07-13 14:23:16', NULL, '1', '0', 0, 0, 0, '0', '1149927250985095168', '其他', 'http://132.232.104.247/#/blog/1149927249663889408', '0');
INSERT INTO `tb_article` VALUES ('1149953409626017792', NULL, '测试试试', '12222', '<p>这是一个嗯日哦那个开发；第三方</p>\n', '这是一个嗯日哦那个开发；第三方', 'http://132.232.104.247:9999/group1/M00/00/00/rBsACV0pkRWAFBOiAATbsC2-_Bg053.jpg', '2019-07-13 16:07:13', NULL, '1', '0', 0, 0, 0, '0', '1147422697949630464', '', 'http://132.232.104.247/#/blog/1149953409626017792', '0');
INSERT INTO `tb_article` VALUES ('1149954077229191168', NULL, '111', '1111', '<p>12321321</p>', '12321321\n', '', '2019-07-13 16:09:52', NULL, '1', '0', 0, 0, 0, '0', '1147422697949630464', '', 'http://132.232.104.247/#/blog/1149954077229191168', '0');
INSERT INTO `tb_article` VALUES ('1149954180941746176', NULL, '1111', '1111', '<p>123213</p>\n', '123213', '', '2019-07-13 16:10:17', NULL, '1', '0', 0, 0, 0, '0', '1147422697949630464', '', 'http://132.232.104.247/#/blog/1149954180941746176', '0');
INSERT INTO `tb_article` VALUES ('1149960175378108416', NULL, '123', '123', '<p>11111</p>\n', '11111', '', '2019-07-13 16:34:06', NULL, '1', '0', 0, 0, 0, '0', '1147422697949630464', '', 'http://132.232.104.247/#/blog/1149960175378108416', '0');
INSERT INTO `tb_article` VALUES ('1149960576533925888', NULL, '12', '321', '<p>1111</p>', '1111\n', '', '2019-07-13 16:35:41', NULL, '1', '0', 0, 0, 0, '0', '1147422697949630464', '', 'http://132.232.104.247/#/blog/1149960576533925888', '0');
COMMIT;

-- ----------------------------
-- Table structure for tb_images
-- ----------------------------
DROP TABLE IF EXISTS `tb_images`;
CREATE TABLE `tb_images` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '图片id',
  `image_origin_name` varchar(200) DEFAULT NULL COMMENT '图片原始名称',
  `image_name` varchar(100) DEFAULT NULL COMMENT '图片名称',
  `image_path` varchar(200) DEFAULT NULL COMMENT '图片上传路径',
  `path` varchar(200) DEFAULT NULL COMMENT '图片访问路径',
  `create_time` date DEFAULT NULL COMMENT '上传时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=51 DEFAULT CHARSET=utf8 COMMENT='图片上传记录';

-- ----------------------------
-- Records of tb_images
-- ----------------------------
BEGIN;
INSERT INTO `tb_images` VALUES (2, 'p4m-info-1.png', 'rBsACV0gI2SAQ48jAAOn6JA93PY661.png', 'group1/M00/00/00/rBsACV0gI2SAQ48jAAOn6JA93PY661.png', 'http://132.232.104.247:9999/group1/M00/00/00/rBsACV0gI2SAQ48jAAOn6JA93PY661.png', '2019-07-06');
INSERT INTO `tb_images` VALUES (3, 'p4m-info-1.png', 'rBsACV0gJoCAZ7-QAAOn6JA93PY761.png', 'group1/M00/00/00/rBsACV0gJoCAZ7-QAAOn6JA93PY761.png', 'http://132.232.104.247:9999/group1/M00/00/00/rBsACV0gJoCAZ7-QAAOn6JA93PY761.png', '2019-07-06');
INSERT INTO `tb_images` VALUES (4, 'p4m-info-1.png', 'rBsACV0gJpuAJRBsAAOn6JA93PY114.png', 'group1/M00/00/00/rBsACV0gJpuAJRBsAAOn6JA93PY114.png', 'http://132.232.104.247:9999/group1/M00/00/00/rBsACV0gJpuAJRBsAAOn6JA93PY114.png', '2019-07-06');
INSERT INTO `tb_images` VALUES (5, 'p4m-info-1.png', 'rBsACV0gPFCAc1lrAAOn6JA93PY315.png', 'group1/M00/00/00/rBsACV0gPFCAc1lrAAOn6JA93PY315.png', 'http://132.232.104.247:9999/group1/M00/00/00/rBsACV0gPFCAc1lrAAOn6JA93PY315.png', '2019-07-06');
INSERT INTO `tb_images` VALUES (6, '1553220431273.jpg', 'rBsACV0gPLaAPZa7AATbsC2-_Bg935.jpg', 'group1/M00/00/00/rBsACV0gPLaAPZa7AATbsC2-_Bg935.jpg', 'http://132.232.104.247:9999/group1/M00/00/00/rBsACV0gPLaAPZa7AATbsC2-_Bg935.jpg', '2019-07-06');
INSERT INTO `tb_images` VALUES (7, '1553220431273.jpg', 'rBsACV0gPUGAKm9WAATbsC2-_Bg403.jpg', 'group1/M00/00/00/rBsACV0gPUGAKm9WAATbsC2-_Bg403.jpg', 'http://132.232.104.247:9999/group1/M00/00/00/rBsACV0gPUGAKm9WAATbsC2-_Bg403.jpg', '2019-07-06');
INSERT INTO `tb_images` VALUES (8, '1553220431273.jpg', 'rBsACV0gPqeANvHWAATbsC2-_Bg116.jpg', 'group1/M00/00/00/rBsACV0gPqeANvHWAATbsC2-_Bg116.jpg', 'http://132.232.104.247:9999/group1/M00/00/00/rBsACV0gPqeANvHWAATbsC2-_Bg116.jpg', '2019-07-06');
INSERT INTO `tb_images` VALUES (9, '1553220431273.jpg', 'rBsACV0gP0aAGkkaAATbsC2-_Bg356.jpg', 'group1/M00/00/00/rBsACV0gP0aAGkkaAATbsC2-_Bg356.jpg', 'http://132.232.104.247:9999/group1/M00/00/00/rBsACV0gP0aAGkkaAATbsC2-_Bg356.jpg', '2019-07-06');
INSERT INTO `tb_images` VALUES (10, 'p4m-info-1.png', 'rBsACV0gQ4yASWl7AAOn6JA93PY417.png', 'group1/M00/00/00/rBsACV0gQ4yASWl7AAOn6JA93PY417.png', 'http://132.232.104.247:9999/group1/M00/00/00/rBsACV0gQ4yASWl7AAOn6JA93PY417.png', '2019-07-06');
INSERT INTO `tb_images` VALUES (11, '68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f322f32362f313639323761656230356637323061393f773d36303726683d38353126663d706e6726733d3931373133.png', 'rBsACV0gQ8CAB0fwAAFmQSzH81U499.png', 'group1/M00/00/00/rBsACV0gQ8CAB0fwAAFmQSzH81U499.png', 'http://132.232.104.247:9999/group1/M00/00/00/rBsACV0gQ8CAB0fwAAFmQSzH81U499.png', '2019-07-06');
INSERT INTO `tb_images` VALUES (12, '1553220431273.jpg', 'rBsACV0gRe2AB_23AATbsC2-_Bg883.jpg', 'group1/M00/00/00/rBsACV0gRe2AB_23AATbsC2-_Bg883.jpg', 'http://132.232.104.247:9999/group1/M00/00/00/rBsACV0gRe2AB_23AATbsC2-_Bg883.jpg', '2019-07-06');
INSERT INTO `tb_images` VALUES (13, 'p4m-info-1.png', 'rBsACV0gSoKAH9DBAAOn6JA93PY062.png', 'group1/M00/00/00/rBsACV0gSoKAH9DBAAOn6JA93PY062.png', 'http://132.232.104.247:9999/group1/M00/00/00/rBsACV0gSoKAH9DBAAOn6JA93PY062.png', '2019-07-06');
INSERT INTO `tb_images` VALUES (14, '_Users_alan.chen_Downloads_data_demo.html.png', 'rBsACV0gTnyAZv86AANKaIY5CUs897.png', 'group1/M00/00/00/rBsACV0gTnyAZv86AANKaIY5CUs897.png', 'http://132.232.104.247:9999/group1/M00/00/00/rBsACV0gTnyAZv86AANKaIY5CUs897.png', '2019-07-06');
INSERT INTO `tb_images` VALUES (15, '_Users_alan.chen_Downloads_data_demo.html (3).png', 'rBsACV0gTv2AdxqxAAQWFWYIb2k049.png', 'group1/M00/00/00/rBsACV0gTv2AdxqxAAQWFWYIb2k049.png', 'http://132.232.104.247:9999/group1/M00/00/00/rBsACV0gTv2AdxqxAAQWFWYIb2k049.png', '2019-07-06');
INSERT INTO `tb_images` VALUES (16, '折线图堆叠.png', 'rBsACV0gT8aABqlCAACoXS6nses922.png', 'group1/M00/00/00/rBsACV0gT8aABqlCAACoXS6nses922.png', 'http://132.232.104.247:9999/group1/M00/00/00/rBsACV0gT8aABqlCAACoXS6nses922.png', '2019-07-06');
INSERT INTO `tb_images` VALUES (17, '折线图堆叠.png', 'rBsACV0gWDuAQ8VEAACoXS6nses371.png', 'group1/M00/00/00/rBsACV0gWDuAQ8VEAACoXS6nses371.png', 'http://132.232.104.247:9999/group1/M00/00/00/rBsACV0gWDuAQ8VEAACoXS6nses371.png', '2019-07-06');
INSERT INTO `tb_images` VALUES (18, '折线图数据分析.png', 'rBsACV0gWiKAYijDAADUTIre4BM006.png', 'group1/M00/00/00/rBsACV0gWiKAYijDAADUTIre4BM006.png', 'http://132.232.104.247:9999/group1/M00/00/00/rBsACV0gWiKAYijDAADUTIre4BM006.png', '2019-07-06');
INSERT INTO `tb_images` VALUES (19, '折线图数据分析.png', 'rBsACV0gW4GAU0nVAADUTIre4BM896.png', 'group1/M00/00/00/rBsACV0gW4GAU0nVAADUTIre4BM896.png', 'http://132.232.104.247:9999/group1/M00/00/00/rBsACV0gW4GAU0nVAADUTIre4BM896.png', '2019-07-06');
INSERT INTO `tb_images` VALUES (20, '折线图数据分析.png', 'rBsACV0gW9-AMaWjAADUTIre4BM033.png', 'group1/M00/00/00/rBsACV0gW9-AMaWjAADUTIre4BM033.png', 'http://132.232.104.247:9999/group1/M00/00/00/rBsACV0gW9-AMaWjAADUTIre4BM033.png', '2019-07-06');
INSERT INTO `tb_images` VALUES (21, '折线图数据分析.png', 'rBsACV0gXCyAa46QAADUTIre4BM964.png', 'group1/M00/00/00/rBsACV0gXCyAa46QAADUTIre4BM964.png', 'http://132.232.104.247:9999/group1/M00/00/00/rBsACV0gXCyAa46QAADUTIre4BM964.png', '2019-07-06');
INSERT INTO `tb_images` VALUES (22, '折线图堆叠.png', 'rBsACV0gXkaAMRnIAACoXS6nses396.png', 'group1/M00/00/00/rBsACV0gXkaAMRnIAACoXS6nses396.png', 'http://132.232.104.247:9999/group1/M00/00/00/rBsACV0gXkaAMRnIAACoXS6nses396.png', '2019-07-06');
INSERT INTO `tb_images` VALUES (23, '1553220431273.jpg', 'rBsACV0gXlOAS4VfAATbsC2-_Bg230.jpg', 'group1/M00/00/00/rBsACV0gXlOAS4VfAATbsC2-_Bg230.jpg', 'http://132.232.104.247:9999/group1/M00/00/00/rBsACV0gXlOAS4VfAATbsC2-_Bg230.jpg', '2019-07-06');
INSERT INTO `tb_images` VALUES (24, '123.png', 'rBsACV0gaViACv1GAAFmQSzH81U392.png', 'group1/M00/00/00/rBsACV0gaViACv1GAAFmQSzH81U392.png', 'http://132.232.104.247:9999/group1/M00/00/00/rBsACV0gaViACv1GAAFmQSzH81U392.png', '2019-07-06');
INSERT INTO `tb_images` VALUES (25, '_Users_alan.chen_Downloads_data_demo.html.png', 'rBsACV0gdSuAfWFwAANKaIY5CUs968.png', 'group1/M00/00/00/rBsACV0gdSuAfWFwAANKaIY5CUs968.png', 'http://132.232.104.247:9999/group1/M00/00/00/rBsACV0gdSuAfWFwAANKaIY5CUs968.png', '2019-07-06');
INSERT INTO `tb_images` VALUES (26, 'Untitled Diagram.jpg', 'rBsACV0pU36AcNjvAADnbSJ_EYQ784.jpg', 'group1/M00/00/00/rBsACV0pU36AcNjvAADnbSJ_EYQ784.jpg', 'http://132.232.104.247:9999/group1/M00/00/00/rBsACV0pU36AcNjvAADnbSJ_EYQ784.jpg', '2019-07-13');
INSERT INTO `tb_images` VALUES (27, '123.png', 'rBsACV0pVSeAH2wXAAFmQSzH81U917.png', 'group1/M00/00/00/rBsACV0pVSeAH2wXAAFmQSzH81U917.png', 'http://132.232.104.247:9999/group1/M00/00/00/rBsACV0pVSeAH2wXAAFmQSzH81U917.png', '2019-07-13');
INSERT INTO `tb_images` VALUES (28, '折线图堆叠.png', 'rBsACV0pVXuAAx9ZAACoXS6nses763.png', 'group1/M00/00/00/rBsACV0pVXuAAx9ZAACoXS6nses763.png', 'http://132.232.104.247:9999/group1/M00/00/00/rBsACV0pVXuAAx9ZAACoXS6nses763.png', '2019-07-13');
INSERT INTO `tb_images` VALUES (29, '折线图堆叠.png', 'rBsACV0pVbmAJl-8AACoXS6nses534.png', 'group1/M00/00/00/rBsACV0pVbmAJl-8AACoXS6nses534.png', 'http://132.232.104.247:9999/group1/M00/00/00/rBsACV0pVbmAJl-8AACoXS6nses534.png', '2019-07-13');
INSERT INTO `tb_images` VALUES (30, '123.png', 'rBsACV0pVgeAPherAAFmQSzH81U438.png', 'group1/M00/00/00/rBsACV0pVgeAPherAAFmQSzH81U438.png', 'http://132.232.104.247:9999/group1/M00/00/00/rBsACV0pVgeAPherAAFmQSzH81U438.png', '2019-07-13');
INSERT INTO `tb_images` VALUES (31, '123.png', 'rBsACV0pVmKAERL1AAFmQSzH81U880.png', 'group1/M00/00/00/rBsACV0pVmKAERL1AAFmQSzH81U880.png', 'http://132.232.104.247:9999/group1/M00/00/00/rBsACV0pVmKAERL1AAFmQSzH81U880.png', '2019-07-13');
INSERT INTO `tb_images` VALUES (32, '123.png', 'rBsACV0pVomAHQvHAAFmQSzH81U476.png', 'group1/M00/00/00/rBsACV0pVomAHQvHAAFmQSzH81U476.png', 'http://132.232.104.247:9999/group1/M00/00/00/rBsACV0pVomAHQvHAAFmQSzH81U476.png', '2019-07-13');
INSERT INTO `tb_images` VALUES (33, '1553220431273.jpg', 'rBsACV0pZLqAAQMcAATbsC2-_Bg613.jpg', 'group1/M00/00/00/rBsACV0pZLqAAQMcAATbsC2-_Bg613.jpg', 'http://132.232.104.247:9999/group1/M00/00/00/rBsACV0pZLqAAQMcAATbsC2-_Bg613.jpg', '2019-07-13');
INSERT INTO `tb_images` VALUES (34, '1553220431273.jpg', 'rBsACV0pZPWAdn6SAATbsC2-_Bg262.jpg', 'group1/M00/00/00/rBsACV0pZPWAdn6SAATbsC2-_Bg262.jpg', 'http://132.232.104.247:9999/group1/M00/00/00/rBsACV0pZPWAdn6SAATbsC2-_Bg262.jpg', '2019-07-13');
INSERT INTO `tb_images` VALUES (35, '1553220431273.jpg', 'rBsACV0pZZOACPOWAATbsC2-_Bg356.jpg', 'group1/M00/00/00/rBsACV0pZZOACPOWAATbsC2-_Bg356.jpg', 'http://132.232.104.247:9999/group1/M00/00/00/rBsACV0pZZOACPOWAATbsC2-_Bg356.jpg', '2019-07-13');
INSERT INTO `tb_images` VALUES (36, '68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f322f32362f313639323761656230356637323061393f773d36303726683d38353126663d706e6726733d3931373133.png', 'rBsACV0pZeuAadGoAAFmQSzH81U907.png', 'group1/M00/00/00/rBsACV0pZeuAadGoAAFmQSzH81U907.png', 'http://132.232.104.247:9999/group1/M00/00/00/rBsACV0pZeuAadGoAAFmQSzH81U907.png', '2019-07-13');
INSERT INTO `tb_images` VALUES (37, '1553220431273.jpg', 'rBsACV0pZhWADW5vAATbsC2-_Bg766.jpg', 'group1/M00/00/00/rBsACV0pZhWADW5vAATbsC2-_Bg766.jpg', 'http://132.232.104.247:9999/group1/M00/00/00/rBsACV0pZhWADW5vAATbsC2-_Bg766.jpg', '2019-07-13');
INSERT INTO `tb_images` VALUES (38, 'p4m-info-1.png', 'rBsACV0pZsSAe00RAAOn6JA93PY154.png', 'group1/M00/00/00/rBsACV0pZsSAe00RAAOn6JA93PY154.png', 'http://132.232.104.247:9999/group1/M00/00/00/rBsACV0pZsSAe00RAAOn6JA93PY154.png', '2019-07-13');
INSERT INTO `tb_images` VALUES (39, '1553220431273.jpg', 'rBsACV0pZzCAAy9rAATbsC2-_Bg709.jpg', 'group1/M00/00/00/rBsACV0pZzCAAy9rAATbsC2-_Bg709.jpg', 'http://132.232.104.247:9999/group1/M00/00/00/rBsACV0pZzCAAy9rAATbsC2-_Bg709.jpg', '2019-07-13');
INSERT INTO `tb_images` VALUES (40, 'p4m-info-1.png', 'rBsACV0paoaAFgtTAAOn6JA93PY020.png', 'group1/M00/00/00/rBsACV0paoaAFgtTAAOn6JA93PY020.png', 'http://132.232.104.247:9999/group1/M00/00/00/rBsACV0paoaAFgtTAAOn6JA93PY020.png', '2019-07-13');
INSERT INTO `tb_images` VALUES (41, 'p4m-info-1.png', 'rBsACV0pauWAQQk0AAOn6JA93PY502.png', 'group1/M00/00/00/rBsACV0pauWAQQk0AAOn6JA93PY502.png', 'http://132.232.104.247:9999/group1/M00/00/00/rBsACV0pauWAQQk0AAOn6JA93PY502.png', '2019-07-13');
INSERT INTO `tb_images` VALUES (42, 'p4m-info-1.png', 'rBsACV0pauuAOw6OAAOn6JA93PY895.png', 'group1/M00/00/00/rBsACV0pauuAOw6OAAOn6JA93PY895.png', 'http://132.232.104.247:9999/group1/M00/00/00/rBsACV0pauuAOw6OAAOn6JA93PY895.png', '2019-07-13');
INSERT INTO `tb_images` VALUES (43, 'p4m-info-1.png', 'rBsACV0pau-AGObIAAOn6JA93PY745.png', 'group1/M00/00/00/rBsACV0pau-AGObIAAOn6JA93PY745.png', 'http://132.232.104.247:9999/group1/M00/00/00/rBsACV0pau-AGObIAAOn6JA93PY745.png', '2019-07-13');
INSERT INTO `tb_images` VALUES (44, '1553220431273.jpg', 'rBsACV0pc6-AcGq5AATbsC2-_Bg040.jpg', 'group1/M00/00/00/rBsACV0pc6-AcGq5AATbsC2-_Bg040.jpg', 'http://132.232.104.247:9999/group1/M00/00/00/rBsACV0pc6-AcGq5AATbsC2-_Bg040.jpg', '2019-07-13');
INSERT INTO `tb_images` VALUES (45, 'public-bg-1.jpg', 'rBsACV0pdBWAZaC8AAhct7uzQqU877.jpg', 'group1/M00/00/00/rBsACV0pdBWAZaC8AAhct7uzQqU877.jpg', 'http://132.232.104.247:9999/group1/M00/00/00/rBsACV0pdBWAZaC8AAhct7uzQqU877.jpg', '2019-07-13');
INSERT INTO `tb_images` VALUES (46, '1553220431273.jpg', 'rBsACV0pdEuAA6NgAATbsC2-_Bg287.jpg', 'group1/M00/00/00/rBsACV0pdEuAA6NgAATbsC2-_Bg287.jpg', 'http://132.232.104.247:9999/group1/M00/00/00/rBsACV0pdEuAA6NgAATbsC2-_Bg287.jpg', '2019-07-13');
INSERT INTO `tb_images` VALUES (47, '1553220431273.jpg', 'rBsACV0pdVKAaN0iAATbsC2-_Bg929.jpg', 'group1/M00/00/00/rBsACV0pdVKAaN0iAATbsC2-_Bg929.jpg', 'http://132.232.104.247:9999/group1/M00/00/00/rBsACV0pdVKAaN0iAATbsC2-_Bg929.jpg', '2019-07-13');
INSERT INTO `tb_images` VALUES (48, '1553220431273.jpg', 'rBsACV0pdYyAUKfBAATbsC2-_Bg139.jpg', 'group1/M00/00/00/rBsACV0pdYyAUKfBAATbsC2-_Bg139.jpg', 'http://132.232.104.247:9999/group1/M00/00/00/rBsACV0pdYyAUKfBAATbsC2-_Bg139.jpg', '2019-07-13');
INSERT INTO `tb_images` VALUES (49, 'p4m-info-1.png', 'rBsACV0pd5mAZPKPAAOn6JA93PY118.png', 'group1/M00/00/00/rBsACV0pd5mAZPKPAAOn6JA93PY118.png', 'http://132.232.104.247:9999/group1/M00/00/00/rBsACV0pd5mAZPKPAAOn6JA93PY118.png', '2019-07-13');
INSERT INTO `tb_images` VALUES (50, '1553220431273.jpg', 'rBsACV0pkRWAFBOiAATbsC2-_Bg053.jpg', 'group1/M00/00/00/rBsACV0pkRWAFBOiAATbsC2-_Bg053.jpg', 'http://132.232.104.247:9999/group1/M00/00/00/rBsACV0pkRWAFBOiAATbsC2-_Bg053.jpg', '2019-07-13');
COMMIT;

SET FOREIGN_KEY_CHECKS = 1;
